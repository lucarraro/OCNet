[{"path":"https://lucarraro.github.io/OCNet/articles/OCNet.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"An introduction to OCNet","text":"OCNet enables creation analysis Optimal Channel Networks (OCNs). oriented spanning trees (built rectangular lattices made square pixels) reproduce scaling features characteristic real, natural river networks (Rodriguez-Iturbe et al. 1992; Rinaldo et al. 2014). , can used variety numerical laboratory experiments fields hydrology, ecology epidemiology. Notable examples include studies metapopulations metacommunities (e.g. Carrara et al. 2012), scenarios waterborne pathogen invasions (e.g. Gatto et al. 2013) biogeochemichal processes streams (e.g. Helton, Hall, Bertuzzo 2018). OCNs obtained minimization functional represents total energy dissipated water flowing network spanning lattice. formulation embeds evidence morphological hydrological characteristics rivers (particular, water discharge slope) follow power-law scaling drainage area. overview functionalities package, see Carraro et al. (2020). details theoretical foundation OCN concept, see Rinaldo et al. (2014).","code":""},{"path":"https://lucarraro.github.io/OCNet/articles/OCNet.html","id":"some-useful-definitions","dir":"Articles","previous_headings":"","what":"Some useful definitions","title":"An introduction to OCNet","text":"graph theory, oriented spanning tree subgraph graph \\(G\\) : oriented: edges’ directions assigned none pairs nodes linked two symmetric edges; spanning: contains nodes \\(G\\); tree: weakly connected (exists path pair nodes, edges’ directions neglected) acyclic (loops present). simplest aggregation level (flow direction - FD; see Section @ref(sec:agg) ), OCNs oriented spanning trees whose nodes pixels constituting lattice whose edges represent flow directions. Moreover, OCNs, just like real rivers, constituted nodes whose indegree (.e. number edges pointing towards node) can assume value outdegree (number edges exiting node) equal 1, except root (outlet node), whose outdegree equal 0. Nodes null indegree termed sources. Nodes indegree larger 1 confluences. OCNet also allows building multiple networks within single lattice. networks defined respective outlet, represents root subgraph; union subgraphs contains elements \\(G\\). simplicity, still refer “OCNs” regards multiple-outlet entities. case, strictly speaking, OCNs trees rather forests. OCN defined adjacency matrix \\(\\mathbf{W}\\) entries \\(w_{ij}\\) equal 1 node \\(\\) drains \\(j\\) null otherwise. Owing previously described properties, rows \\(\\mathbf{W}\\) single non-zero entry, except identifying outlet nodes, whose entries null. adjacency matrix uniquely defines vector contributing areas (drainage areas) \\(\\mathbf{}\\), whose components \\(A_i\\) equal number nodes upstream node \\(\\) plus node . Mathematically, can expressed \\((\\mathbf{}-\\mathbf{W}^T)\\mathbf{}=\\mathbf{1}\\), \\(\\mathbf{}\\) identity matrix \\(\\mathbf{1}\\) vector ones.","code":""},{"path":"https://lucarraro.github.io/OCNet/articles/OCNet.html","id":"ocnet-functions-dependency-tree","dir":"Articles","previous_headings":"","what":"OCNet functions dependency tree","title":"An introduction to OCNet","text":"generation OCN performed function create_OCN. required inputs dimensions rectangular lattice, several features can implemented via optional inputs (see function documentation details). output create_OCN list, can used input subsequent function landscape_OCN, shown dependency tree (indentation item implies dependency function level). draw_thematic_OCN: draws OCN colors nodes depending theme draw_subcatchments_OCN: draws partition lattice subcatchments result aggregation process OCN paths_OCN: calculates paths path lengths among OCN nodes rivergeometry_OCN: evaluates hydraulic properties OCN OCN_to_igraph: transforms OCN igraph object OCN_to_SSN: transforms OCN SpatialStreamNetwork object draw_contour_OCN: draws “real-shaped”1 OCNs catchment contours draw_elev2D_OCN: draws 2D elevation field draw_elev3D_OCN: draws 3D elevation field draw_elev3Drgl_OCN: draws 3D elevation field (via rgl rendering system) find_area_threshold_OCN: finds relationship threshold area number nodes RN AG level (see Figure @ref(fig:ex-net) relevant definitions) draw_simple_OCN: fast drawing OCNs create_peano: creates Peano networks OCNet functions intended applied sequential order: non-drawing function, input list copied output list, new sublists objects added.","code":""},{"path":"https://lucarraro.github.io/OCNet/articles/OCNet.html","id":"sec:agg","dir":"Articles","previous_headings":"","what":"Aggregation levels","title":"An introduction to OCNet","text":"Adjacency matrices contributing area vectors OCN can defined different aggregation levels. output OCNet functions, variables characterizing OCN different aggregation levels grouped within separate sublists, identified two-letter acronym (marked bold list ). Figure @ref(fig:ex-net) provides graphical visualization correspondence among main aggregation levels. Nearest neighbours (N4, N8). Every pixel lattice constitutes node network. node connected four (pixels share edge) eight (pixels share edge vertex) nearest neighbours. level, \\(\\mathbf{W}\\) defined \\(\\mathbf{}\\) . Note level describe flow connectivity, rather proximity among pixels. Hence, \\(\\mathbf{W}\\) describe oriented spanning tree. Flow direction (FD). level, every pixel lattice node, connectivity follows flow directions found OCN search algorithm (operated function create_OCN). Edges’ lengths equal either cellsize (size pixel side, optional input create_OCN) cellsize*sqrt(2), depending whether flow direction horizontal/vertical diagonal. River network (RN). set nodes level subset nodes FD level, contributing area larger certain threshold (optional input A_thr aggregate_OCN). procedure customary hydrological problem extracting river network based digital elevation models terrain (O’Callaghan Mark 1984), corresponds geomorphological concept erosion threshold (associated threshold landscape-forming runoff, drainage area represents proxy Rodriguez-Iturbe Rinaldo 2001). Edges’ lengths equal either cellsize cellsize*sqrt(2). Aggregated (reach - AG). set nodes level subset nodes RN level (see details next section). Accordingly, vector \\(\\mathbf{}\\) subset vector name defined RN level. Edges can span several pixels therefore various lengths. Subcatchment (SC). number nodes level generally2 equal AG level. node constituted cluster pixels directly drain edge departing corresponding node AG level. \\(\\mathbf{W}\\) represent flow connectivity rather identifies terrestrial borders among subcatchments therefore symmetric. Catchment (CM). level, number nodes equal number outlets. Every node represents portion lattice drained relative outlet. \\(\\mathbf{}\\) stores drainage area values catchments, \\(\\mathbf{W}\\) identifies terrestrial borders among catchments. Representation different aggregation levels network defined (excluding null levels N4 N8). example obtained single-outlet 8x8 lattice. Letter ‘O’ identifies outlet pixel. Arrows pixels identify flow directions. Numbers represent cumulative drainage area (number pixels). FD level, 64 pixels belong network3. obtain RN level, threshold value 5 drainage area applied distinguish pixels belonging river network. network AG level consists 9 nodes. SC level obtained splitting lattice portions whose pixels drain AG nodes edges. example, one outlet, pixels belong single node CM level.","code":""},{"path":"https://lucarraro.github.io/OCNet/articles/OCNet.html","id":"relationship-between-nodes-at-the-rn-and-ag-levels","dir":"Articles","previous_headings":"Aggregation levels","what":"Relationship between nodes at the RN and AG levels","title":"An introduction to OCNet","text":"Nodes AG level correspond subset nodes RN level. particular, nodes AG level belong least one four categories: Sources: nodes RN level null indegree. Confluences: nodes RN level indegree larger one. Outlets: corresponding outlets RN level. Breaking nodes (maxReachLength finite): nodes split edges longer maxReachLength. Outlet nodes AG level might also sources, confluences breaking nodes. AG nodes except outlet nodes outdegree equal 1. RN nodes correspond AG nodes constitute edges network AG level: specifically, edge formed AG node sequence RN nodes downstream AG node, another AG node found. Figure @ref(fig:ex3-net) shows alternative aggregation scheme network showed Figure @ref(fig:ex-net) optional input maxReachLength set finite value. Aggregation previous network A_thr equal 5 pixels maxReachLength equal 3 pixel sides. Note length diagonal segments edges equal sqrt(2).","code":""},{"path":"https://lucarraro.github.io/OCNet/articles/OCNet.html","id":"correspondence-between-indices-at-different-levels","dir":"Articles","previous_headings":"Aggregation levels","what":"Correspondence between indices at different levels","title":"An introduction to OCNet","text":"output aggregate_OCN contains objects named OCN$XX$toYY, XX YY two different aggregation levels. objects define correspondences indices among aggregation levels. OCN$XX$toYY contains number elements equal number nodes XX level; element OCN$XX$toYY[[]] contains index/indices YY level corresponding node XX level. aggregation level AG, additional correspondence objects marked string Reach: consider whole sequence RN nodes constituting edge departing AG node belonging AG node. example shown Figure @ref(fig:ex-ind) corresponds dataset OCN_4 included package. Note index numbering starts lower-left (southwestern) corner lattice. Top-left panel: arrows display flow directions, numbers identify contributing areas. Bottom-left panel: network aggregated imposing threshold equal 2 pixels. panels display indices nodes different aggregation levels. R code displays different OCN$XX$toYY objects corresponding example Figure @ref(fig:ex-ind):","code":"ex <- aggregate_OCN(landscape_OCN(OCN_4), thrA = 2)  ex$FD$toRN #>  [1] 1 2 3 0 4 0 0 5 6 7 0 0 0 0 8 0 ex$FD$toSC #>  [1] 1 3 3 3 2 3 3 3 4 5 5 3 4 5 5 5  ex$RN$toFD #> [1]  1  2  3  5  8  9 10 15 ex$RN$toAG #> [1] 1 0 0 2 3 4 0 5 ex$RN$toAGReach #> [1] 1 3 3 2 3 4 5 5  ex$AG$toFD #> [1]  1  5  8  9 15 ex$AG$ReachToFD #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 5 #>  #> [[3]] #> [1] 2 3 8 #>  #> [[4]] #> [1] 9 #>  #> [[5]] #> [1] 10 15 ex$AG$toRN #> [1] 1 4 5 6 8 ex$AG$ReachToRN #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 4 #>  #> [[3]] #> [1] 2 3 5 #>  #> [[4]] #> [1] 6 #>  #> [[5]] #> [1] 7 8  ex$SC$toFD #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 5 #>  #> [[3]] #> [1]  2  3  8  4  6  7 12 #>  #> [[4]] #> [1]  9 13 #>  #> [[5]] #> [1] 10 15 11 14 16"},{"path":"https://lucarraro.github.io/OCNet/articles/OCNet.html","id":"a-working-example","dir":"Articles","previous_headings":"","what":"A working example","title":"An introduction to OCNet","text":"Let’s build OCN 20x20 lattice assume cell represents square side 500 m. total size catchment therefore 100 km2. Let’s locate outlet close southwestern corner lattice. Function draw_simple_OCN can used display OCN.  Now, let’s construct elevation field subsumed OCN. Let’s suppose outlet null elevation slope equal 0.01. , use draw_elev3D_OCN draw three-dimensional elevation map (values m).  Next, OCN can aggregated. Let’s suppose desired number nodes AG level close possible4 20. function find_area_threshold_OCN can derive corresponding value drainage area threshold: resulting number nodes is5 20, corresponding threshold area thrA20 = 2.5 km2. latter value can now used function aggregate_OCN obtain aggregated network. Function draw_subcatchments_OCN shows lattice partitioned subcatchments. possible add points locations nodes AG level.  Finally, draw_thematic_OCN can used display along-stream distances RN-level nodes outlet (m), calculated paths_OCN.","code":"set.seed(1) OCNwe <- create_OCN(20, 20, outletPos = 3, cellsize = 500) par(mai=c(0,0,0,0)) draw_simple_OCN(OCNwe) OCNwe <- landscape_OCN(OCNwe, slope0 = 0.01) par(mai=c(0,0,0,0.5)) draw_elev3D_OCN(OCNwe, drawRiver = FALSE) thr <- find_area_threshold_OCN(OCNwe) # find index corresponding to thr$Nnodes ~= 20 indThr <- which(abs(thr$nNodesAG - 20) == min(abs(thr$nNodesAG - 20))) indThr <- max(indThr) # pick the last ind_thr that satisfies the condition above thrA20 <- thr$thrValues[indThr] # corresponding threshold area OCNwe <- aggregate_OCN(OCNwe, thrA = thrA20) par(mai=c(0.1,0,0.1,0)) draw_subcatchments_OCN(OCNwe) points(OCNwe$AG$X,OCNwe$AG$Y, pch = 21, col = \"blue\", bg = \"blue\") OCNwe <- paths_OCN(OCNwe, includePaths = TRUE) par(mai=c(0.1,0,0.1,0)) draw_thematic_OCN(OCNwe$RN$downstreamPathLength[ , OCNwe$RN$outlet], OCNwe,                    backgroundColor = \"#606060\")"},{"path":[]},{"path":"https://lucarraro.github.io/OCNet/articles/OCNet.html","id":"theory","dir":"Articles","previous_headings":"A working example > Application: metapopulation model","what":"Theory","title":"An introduction to OCNet","text":"Let’s build simple discrete-time, deterministic metapopulation model previously built OCN. particular, let’s assume : expected population growth node \\(\\) follows Beverton-Holt model, proliferation rate \\(r\\) carrying capacity \\(K_i\\). timestep, number individuals moving node \\(\\) expressed \\(G(P_i(t),K_i)\\), \\(P_i(t)\\) (expected) population size node \\(\\) time \\(t\\). \\(G(P_i(t),K_i)=G(K_i,K_i)\\cdot P_i(t)/K_i\\), namely number individuals moving node \\(\\) increases linearly \\(P_i(t)\\). timestep, individuals node \\(\\) can move node directly connected \\(\\), either downstream upstream. \\(p_d\\) \\(p_u = 1 - p_d\\) identify probability move downstream upstream, respectively. headwater node \\(\\), due lack upstream connection, actual (expected) number individuals moving \\(\\) time \\(t\\) \\(p_d G(P_i(t),K_i)\\). Vice versa, (expected) number individuals moving outlet \\(o\\) time \\(t\\) \\(p_u G(P_o(t),K_o)\\). indegree node larger one, individuals moving upstream split among possible destination nodes fractions \\(Y\\) proportional drainage areas. Therefore, model equation : \\[ \\begin{split} P_i(t+1) &= \\frac{r P_i(t)}{1+ (r-1)P_i(t)/K_i} - (p_d D_i + p_u U_i)G(K_i,K_i)\\frac{P_i(t)}{K_i} \\\\ &\\quad + p_d \\left( \\sum_{j=1} w_{ji} G(K_j,K_j)\\frac{P_j(t)}{K_j}\\right) + p_u \\left( \\sum_{j=1} w_{ij} Y_i G(K_j,K_j)\\frac{P_j(t)}{K_j}\\right) \\end{split} \\] \\(D_i\\) (\\(U_i\\)) equal one downstream (upstream) connection available node \\(\\) null otherwise. Weights \\(Y_i\\) defined : \\[ Y_i = \\frac{A_i}{\\sum_{k=1} w_{kj}A_k}, \\] \\(j\\) identifies node downstream \\(\\). Moreover, \\(Y_o = 1\\). carrying capacity, system equilibrium, implies (expected) number individuals moving node \\(\\) downstream connection \\(j\\) equal (expected) number individuals moving \\(j\\) \\(\\): \\[ p_d G(K_i,K_i) = p_u Y_i G(K_j,K_j). \\] iterative application equation allows calculation \\(G(K_i,K_i)\\) \\(\\) constant. end, let’s assume \\(G(K_o,K_o) = G_o\\). therefore obtain \\[ G(K_i,K_i) = G_o \\left(\\frac{p_u}{p_d}\\right)^{|P_{io}|} \\prod_{k \\P_{io}} Y_k, \\] \\(P_{io}\\) set nodes constituting downstream path \\(\\) outlet \\(o\\), \\(|P_{io}|\\) cardinality.","code":""},{"path":"https://lucarraro.github.io/OCNet/articles/OCNet.html","id":"implementation","dir":"Articles","previous_headings":"A working example > Application: metapopulation model","what":"Implementation","title":"An introduction to OCNet","text":"example, let’s use previously derived OCN_we aggregated RN level. Let’s assume carrying capacity proportional river width evaluated nodes, initial population distribution randomly assigned. can now compute weights \\(Y\\): \\(G(K_i,K_i)\\): can now run metapopulation model: left panel graph shows time evolution local population outlet (red) node highest distance outlet (blue). right panel, evolution total metapopulation size shown. Dashed lines indicate population values carrying capacity.  Function draw_thematic_OCN can used visualize spatial distribution metapopulation given time points.","code":"## Input data OCNwe <- rivergeometry_OCN(OCNwe, widthMax = 5)   # evaluate river width  K <- 10*OCNwe$RN$width                             # calculate carrying capacity  pop0 <- 2*mean(K)*runif(OCNwe$RN$nNodes)           # initial random population vector nTimestep <- 100                                   # number of timesteps r <- 1.05                                          # proliferation rate pd <- 0.5                                          # probability to move downstream pu <- 1 - pd                                       # probability to move upstream Go <- 5                                            # parameter controlling mobility  # (no. individuals exiting from outlet node at carrying capacity is pu*Go) ## Weights for upstream movement Y <- rep(1,OCNwe$RN$nNodes)                     for (i in 1:OCNwe$RN$nNodes){   if (i != OCNwe$RN$outlet){     Y[i] <- OCNwe$RN$A[i]/(OCNwe$RN$W[ , OCNwe$RN$downNode[i]] %*% OCNwe$RN$A)   } } ## Evaluate expected number of individuals moving at carrying capacity GKK <- rep(0, OCNwe$RN$nNodes) for (i in (1:OCNwe$RN$nNodes)){   path <- OCNwe$RN$downstreamPath[[i]][[OCNwe$RN$outlet]] # select path   prod <- Go                                                # initialize product of Y    for (j in path){     prod <- prod*Y[j]   }   GKK[i] <- (pu/pd)^(length(path))*prod   } ## Run metapopulation model pop <- matrix(data=0,ncol=nTimestep,nrow=OCNwe$RN$nNodes)  # metapopulation matrix pop[,1] <- pop0                                              # initialization for (t in 2:nTimestep){   for (i in 1:OCNwe$RN$nNodes){     pop[i, t] <-        # Beverton-Holt growth model       r*pop[i, t-1]/(1 + pop[i, t-1]*(r-1)/K[i]) +       # individuals exiting from node i                 - (pu*(sum(OCNwe$RN$W[ , i])>0) + pd*(sum(OCNwe$RN$W[i, ])>0)) *        GKK[i] * (pop[i,t-1]/K[i]) +       # individuals entering in i from the upstream nodes                 + pd * OCNwe$RN$W[ , i] %*% (GKK*pop[ , t-1]/K) +       # individuals entering in i from the downstream node                 + pu * Y[i] * OCNwe$RN$W[i, ] %*% (GKK*pop[ , t-1]/K)         } } par(mfrow = c(1, 2)) plot(pop[OCNwe$RN$outlet, ], type = \"l\", ylim = c(0, 1.05*K[OCNwe$RN$outlet]), col = \"red\",       xlab = \"Time\", ylab = \"Population\", lwd = 2) title(\"Evolution of local pop. size\") lines(c(1, nTimestep),c(K[OCNwe$RN$outlet], K[OCNwe$RN$outlet]), col = \"red\", lty = 2) farthestNode <- which(OCNwe$RN$downstreamPathLength[ , OCNwe$RN$outlet]                       == max(OCNwe$RN$downstreamPathLength[ , OCNwe$RN$outlet]))[1] lines(pop[farthestNode, ], type=\"l\", col=\"blue\",lwd=2) lines(c(1, nTimestep), c(K[farthestNode], K[farthestNode]), col = \"blue\", lty = 2)  plot(colSums(pop), type = \"l\", xlab = \"Time\", ylab = \"Population\", lwd = 2, ylim = c(0, 1.05*sum(K))) lines(c(1, nTimestep), c(sum(K),sum(K)), lty = 2) title(\"Evolution of metapop. size\") par(mfrow = c(2, 2), mai = c(0.1, 0, 0.2, 0)) draw_thematic_OCN(pop[,1], OCNwe, colLevels = c(0, max(K), 1000),                   drawNodes = TRUE) title(\"Time = 1\") draw_thematic_OCN(pop[,5], OCNwe, colLevels = c(0, max(K), 1000),                   drawNodes = TRUE) title(\"Time = 5\") draw_thematic_OCN(pop[,20], OCNwe, colLevels = c(0, max(K), 1000),                   drawNodes = TRUE) title(\"Time = 20\") draw_thematic_OCN(pop[,100], OCNwe, colLevels = c(0, max(K), 1000),                   drawNodes = TRUE) title(\"Time = 100\")"},{"path":"https://lucarraro.github.io/OCNet/articles/OCNet.html","id":"peano-networks","dir":"Articles","previous_headings":"","what":"Peano networks","title":"An introduction to OCNet","text":"Function create_peano can used lieu create_OCN generate Peano networks square lattices. Peano networks deterministic, plane-filling fractals whose topological measures (Horton’s bifurcation length ratios) akin real river networks (Marani, Rigon, Rinaldo 1991) can used variety synthetic experiments, case OCNs (e.g. Campos, Fort, Méndez 2006). Peano networks generated means iterative algorithm: iteration, size lattice side doubled (see code ). result, Peano networks span squares side equal power 2. outlet must located corner square.  output create_peano list containing objects produced create_OCN. , can used input complementary functions package.","code":"par(mfrow = c(2, 3), mai = c(0, 0, 0.2, 0)) peano0 <- create_peano(0) draw_simple_OCN(peano0) title(\"Iteration: 0 - Lattice size: 2x2\")  peano1 <- create_peano(1) draw_simple_OCN(peano1) title(\"Iteration: 1 - Lattice size: 4x4\")  peano2 <- create_peano(2) draw_simple_OCN(peano2) title(\"Iteration: 2 - Lattice size: 8x8\")  peano3 <- create_peano(3) draw_simple_OCN(peano3) title(\"Iteration: 3 - Lattice size: 16x16\")  peano4 <- create_peano(4) draw_simple_OCN(peano4) title(\"Iteration: 4 - Lattice size: 32x32\")  peano5 <- create_peano(5) draw_simple_OCN(peano5) title(\"Iteration: 5 - Lattice size: 64x64\") par(mai = c(0, 0, 0, 0)) peano5 <- landscape_OCN(peano5) draw_elev2D_OCN(peano5)"},{"path":"https://lucarraro.github.io/OCNet/articles/OCNet.html","id":"list-of-ready-made-ocns","dir":"Articles","previous_headings":"","what":"List of ready-made OCNs","title":"An introduction to OCNet","text":"OCNet contains ready-made large OCNs built via function create_OCN. features summarized Table . Refer documentation create_OCN definition column names. Note : specified otherwise, position outlet(s) derived default options. cold: corresponds coolingRate = 10, initialNoCoolingPhase = 0; default: corresponds default values coolingRate = 1, initialNoCoolingPhase = 0; hot: corresponds coolingRate = 0.5, initialNoCoolingPhase = 0.1. seed value argument used call set.seed prior executing create_OCN. CRAN? identifies OCNs uploaded version OCNet can downloaded CRAN (owing limitation package size). Installation package GitHub provides complete set OCNs hereafter described6.","code":""},{"path":[]},{"path":"https://lucarraro.github.io/OCNet/articles/OCNet.html","id":"igraph","dir":"Articles","previous_headings":"Compatibility with other packages","what":"igraph","title":"An introduction to OCNet","text":"Adjacency matrices aggregation levels produced spam (Furrer Sain 2010) objects. order transform OCN igraph (Csardi Nepusz 2006) graph object, adjacency matrix must converted Matrix object (via function .dgCMatrix.spam spam). Function graph_from_adjacency_matrix igraph can used obtain graph object. example, let’s transform previously obtained OCN_we AG level graph:  network can displayed OCN:","code":"par(mai=c(0.1,0.1,0.1,0.1)) g <- OCN_to_igraph(OCNwe, level = \"AG\") plot.igraph(g, vertex.color = rainbow(OCNwe$AG$nNodes),       layout = matrix(c(OCNwe$AG$X,OCNwe$AG$Y),ncol = 2, nrow = OCNwe$AG$nNodes)) par(mai=c(0,0,0,0)) draw_thematic_OCN(c(1:OCNwe$AG$nNodes), OCNwe, discreteLevels = TRUE, drawNodes = TRUE,                   colPalette = rainbow,  cex = 3, riverColor = \"#999999\",                   backgroundColor = \"#00000000\", addLegend = FALSE) text(OCNwe$AG$X, OCNwe$AG$Y)"},{"path":"https://lucarraro.github.io/OCNet/articles/OCNet.html","id":"ssn","dir":"Articles","previous_headings":"Compatibility with other packages","what":"SSN","title":"An introduction to OCNet","text":"Function OCN_to_SSN transforms OCN given aggregation level SSN (Ver Hoef et al. 2014) object. See following example:","code":"ssnOCN <- OCN_to_SSN(OCNwe, level = \"RN\", obsDesign = SSN::binomialDesign(50),                      path = paste(tempdir(), \"/OCN.ssn\", sep = \"\"), importToR = TRUE) #> Warning: OGR support is provided by the sf and terra packages among others #> Warning: OGR support is provided by the sf and terra packages among others #> Warning: OGR support is provided by the sf and terra packages among others #> Warning: OGR support is provided by the sf and terra packages among others plot.SpatialStreamNetwork(ssnOCN, \"upDist\", breaktype = \"user\", brks = seq(0,14000,2000),                            xlab = \"x [m]\", ylab = \"y [m]\", asp = 1) title(\"Distance from outlet of observation points [m]\")"},{"path":[]},{"path":"https://lucarraro.github.io/OCNet/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Luca Carraro. Author, maintainer. Florian Altermatt. Contributor. Emanuel . Fronhofer. Contributor. Reinhard Furrer. Contributor. Isabelle Gounand. Contributor. Andrea Rinaldo. Contributor. Enrico Bertuzzo. Author.","code":""},{"path":"https://lucarraro.github.io/OCNet/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Carraro L, Bertuzzo E, Fronhofer EA, Furrer R, Gounand , Rinaldo , Altermatt F (2020). “Generation application river network analogues use ecology evolution.” Ecology Evolution. doi:10.1002/ece3.6479.","code":"@Article{,   title = {Generation and application of river network analogues for use in ecology and evolution},   author = {Luca Carraro and Enrico Bertuzzo and Emanuel A. Fronhofer and Reinhard Furrer and Isabelle Gounand and Andrea Rinaldo and Florian Altermatt},   year = {2020},   journal = {Ecology and Evolution},   doi = {10.1002/ece3.6479}, }"},{"path":"https://lucarraro.github.io/OCNet/index.html","id":"ocnet","dir":"","previous_headings":"","what":"Optimal Channel Networks","title":"Optimal Channel Networks","text":"R-package generate analyze Optimal Channel Networks","code":""},{"path":"https://lucarraro.github.io/OCNet/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Optimal Channel Networks","text":"OCNet enables creation analysis Optimal Channel Networks (OCNs). oriented spanning trees (built rectangular lattices made square pixels) reproduce scaling features characteristic real, natural river networks. , can used variety numerical laboratory experiments fields hydrology, ecology epidemiology. OCNs obtained minimization functional represents total energy dissipated water flowing network spanning lattice. formulation embeds evidence morphological hydrological characteristics rivers (particular, water discharge slope) follow power-law scaling drainage area. details, please see Carraro et al. (2020). Generation application river network analogues use ecology evolution. Ecology Evolution. doi:10.1002/ece3.6479.","code":""},{"path":"https://lucarraro.github.io/OCNet/index.html","id":"a-minimal-working-example","dir":"","previous_headings":"","what":"A minimal working example","title":"Optimal Channel Networks","text":"Set random seed 1 create OCN 30x20 lattice default options: Draw -obtained OCN: OCN 30x20","code":"set.seed(1) OCN <- create_OCN(30,20) draw_simple_OCN(OCN)"},{"path":"https://lucarraro.github.io/OCNet/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Optimal Channel Networks","text":"","code":"# install devtools (if previously not installed) if (!(\"devtools\" %in% installed.packages())) {install.packages(\"devtools\")}  # install OCNet from GitHub devtools::install_github(\"lucarraro/OCNet\", build_vignettes = TRUE)"},{"path":[]},{"path":"https://lucarraro.github.io/OCNet/index.html","id":"windows","dir":"","previous_headings":"Installation issues and workarounds","what":"Windows","title":"Optimal Channel Networks","text":"error might occur version 0.100.47 package rgl installed. Installation rgl_0.100.30 works fine.","code":""},{"path":"https://lucarraro.github.io/OCNet/index.html","id":"linux","dir":"","previous_headings":"Installation issues and workarounds","what":"Linux","title":"Optimal Channel Networks","text":"Installing packages rgdal rgl (imported OCNet) gives rise errors. can solved running","code":"sudo apt install libftgl2 libcgal-dev libglu1-mesa-dev libglu1-mesa-dev apt-get libx11-dev libfreetype6-dev libgdal-dev"},{"path":"https://lucarraro.github.io/OCNet/index.html","id":"authors","dir":"","previous_headings":"","what":"Authors","title":"Optimal Channel Networks","text":"Luca Carraro (maintainer), Florian Altermatt, Emanuel . Fronhofer, Reinhard Furrer, Isabelle Gounand, Andrea Rinaldo, Enrico Bertuzzo","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_20.html","id":null,"dir":"Reference","previous_headings":"","what":"Example of small OCN — OCN_20","title":"Example of small OCN — OCN_20","text":"network built 20x20 lattice obtained executing set.seed(1); create_OCN(20,20).","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_20.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example of small OCN — OCN_20","text":"","code":"data(OCN_20)"},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_20.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example of small OCN — OCN_20","text":"list. See create_OCN documentation details.","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_250.html","id":null,"dir":"Reference","previous_headings":"","what":"Example of single-outlet OCN — OCN_250","title":"Example of single-outlet OCN — OCN_250","text":"network built 250x250 lattice obtained executing set.seed(2); create_OCN(250, 250).","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_250.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example of single-outlet OCN — OCN_250","text":"","code":"data(OCN_250)"},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_250.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example of single-outlet OCN — OCN_250","text":"list. See create_OCN documentation details.","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_250_PB.html","id":null,"dir":"Reference","previous_headings":"","what":"Example of single-outlet OCN with periodic boundaries — OCN_250_PB","title":"Example of single-outlet OCN with periodic boundaries — OCN_250_PB","text":"network built 250x250 lattice obtained executing set.seed(2); create_OCN(250, 250, periodicBoundaries = TRUE).","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_250_PB.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example of single-outlet OCN with periodic boundaries — OCN_250_PB","text":"","code":"data(OCN_250_PB)"},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_250_PB.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example of single-outlet OCN with periodic boundaries — OCN_250_PB","text":"list. See create_OCN documentation details.","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_250_T.html","id":null,"dir":"Reference","previous_headings":"","what":"Example of single-outlet OCN — OCN_250_T","title":"Example of single-outlet OCN — OCN_250_T","text":"network built 250x250 lattice obtained executing set.seed(2); create_OCN(250, 250, typeInitialState = \"T\").","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_250_T.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example of single-outlet OCN — OCN_250_T","text":"","code":"data(OCN_250_T)"},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_250_T.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example of single-outlet OCN — OCN_250_T","text":"list. See create_OCN documentation details.","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_250_V.html","id":null,"dir":"Reference","previous_headings":"","what":"Example of single-outlet OCN — OCN_250_V","title":"Example of single-outlet OCN — OCN_250_V","text":"network built 250x250 lattice obtained executing set.seed(2); create_OCN(250, 250, typeInitialState = \"V\").","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_250_V.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example of single-outlet OCN — OCN_250_V","text":"","code":"data(OCN_250_V)"},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_250_V.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example of single-outlet OCN — OCN_250_V","text":"list. See create_OCN documentation details.","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_250_V_cold.html","id":null,"dir":"Reference","previous_headings":"","what":"Example of single-outlet OCN — OCN_250_V_cold","title":"Example of single-outlet OCN — OCN_250_V_cold","text":"network built 250x250 lattice obtained executing set.seed(2); create_OCN(250, 250, typeInitialState = \"V\", coolingRate = 10).","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_250_V_cold.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example of single-outlet OCN — OCN_250_V_cold","text":"","code":"data(OCN_250_V_cold)"},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_250_V_cold.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example of single-outlet OCN — OCN_250_V_cold","text":"list. See create_OCN documentation details.","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_250_V_hot.html","id":null,"dir":"Reference","previous_headings":"","what":"Example of single-outlet OCN — OCN_250_V_hot","title":"Example of single-outlet OCN — OCN_250_V_hot","text":"network built 250x250 lattice obtained executing set.seed(2); create_OCN(250, 250, typeInitialState = \"V\", coolingRate = 0.5, initialNoCoolingPhase = 0.1).","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_250_V_hot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example of single-outlet OCN — OCN_250_V_hot","text":"","code":"data(OCN_250_V_hot)"},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_250_V_hot.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example of single-outlet OCN — OCN_250_V_hot","text":"list. See create_OCN documentation details.","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_250_cold.html","id":null,"dir":"Reference","previous_headings":"","what":"Example of single-outlet OCN — OCN_250_cold","title":"Example of single-outlet OCN — OCN_250_cold","text":"network built 250x250 lattice obtained executing set.seed(2); create_OCN(250, 250, coolingRate = 10).","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_250_cold.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example of single-outlet OCN — OCN_250_cold","text":"","code":"data(OCN_250_cold)"},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_250_cold.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example of single-outlet OCN — OCN_250_cold","text":"list. See create_OCN documentation details.","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_250_hot.html","id":null,"dir":"Reference","previous_headings":"","what":"Example of single-outlet OCN — OCN_250_hot","title":"Example of single-outlet OCN — OCN_250_hot","text":"network built 250x250 lattice obtained executing set.seed(2); create_OCN(250, 250, coolingRate = 0.5, initialNoCoolingPhase = 0.1).","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_250_hot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example of single-outlet OCN — OCN_250_hot","text":"","code":"data(OCN_250_hot)"},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_250_hot.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example of single-outlet OCN — OCN_250_hot","text":"list. See create_OCN documentation details.","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_300_4out.html","id":null,"dir":"Reference","previous_headings":"","what":"Example of multiple-outlet OCN — OCN_300_4out","title":"Example of multiple-outlet OCN — OCN_300_4out","text":"network built 300x300 lattice obtained executing set.seed(5); create_OCN(300, 300, nOutlet = 4, outletSide = c(\"S\", \"N\", \"W\", \"E\"), outletPos = c(1, 300, 149, 150), typeInitialState = \"V\", cellsize = 50).","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_300_4out.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example of multiple-outlet OCN — OCN_300_4out","text":"","code":"data(OCN_300_4out)"},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_300_4out.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example of multiple-outlet OCN — OCN_300_4out","text":"list. See create_OCN documentation details.","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_300_4out_PB_hot.html","id":null,"dir":"Reference","previous_headings":"","what":"Example of multiple-outlet OCN with periodic boundaries — OCN_300_4out_PB_hot","title":"Example of multiple-outlet OCN with periodic boundaries — OCN_300_4out_PB_hot","text":"network built 300x300 lattice obtained executing set.seed(5); create_OCN(300, 300, nOutlet = 4, outletSide = c(\"S\", \"N\", \"W\", \"E\"), outletPos = c(1, 300, 149, 150), typeInitialState = \"V\", periodicBoundaries = TRUE, cellsize = 50, coolingRate = 0.5, initialNoCoolingPhase = 0.1).","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_300_4out_PB_hot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example of multiple-outlet OCN with periodic boundaries — OCN_300_4out_PB_hot","text":"","code":"data(OCN_300_4out_PB_hot)"},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_300_4out_PB_hot.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example of multiple-outlet OCN with periodic boundaries — OCN_300_4out_PB_hot","text":"list. See create_OCN documentation details.","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_300_7out.html","id":null,"dir":"Reference","previous_headings":"","what":"Example of multiple-outlet OCN — OCN_300_7out","title":"Example of multiple-outlet OCN — OCN_300_7out","text":"network built 300x300 lattice obtained executing set.seed(5); create_OCN(300, 300, nOutlet = 7, cellsize = 50).","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_300_7out.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example of multiple-outlet OCN — OCN_300_7out","text":"","code":"data(OCN_300_7out)"},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_300_7out.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example of multiple-outlet OCN — OCN_300_7out","text":"list. See create_OCN documentation details.","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_300_diag.html","id":null,"dir":"Reference","previous_headings":"","what":"Example of single-outlet OCN — OCN_300_diag","title":"Example of single-outlet OCN — OCN_300_diag","text":"network built 300x300 lattice obtained executing set.seed(4); create_OCN(300, 300, outletPos = 1, typeInitialState = \"V\", cellsize = 50).","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_300_diag.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example of single-outlet OCN — OCN_300_diag","text":"","code":"data(OCN_300_diag)"},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_300_diag.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example of single-outlet OCN — OCN_300_diag","text":"list. See create_OCN documentation details.","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_4.html","id":null,"dir":"Reference","previous_headings":"","what":"Example of small OCN — OCN_4","title":"Example of small OCN — OCN_4","text":"network built 4x4 lattice illustrative purposes.","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_4.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example of small OCN — OCN_4","text":"","code":"data(OCN_4)"},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_4.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example of small OCN — OCN_4","text":"list. See create_OCN documentation details.","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_4.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Example of small OCN — OCN_4","text":"Despite name, network OCN: indeed, generated manually via create_OCN.","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_400_Allout.html","id":null,"dir":"Reference","previous_headings":"","what":"Example of OCN with all perimetric pixels as outlets — OCN_400_Allout","title":"Example of OCN with all perimetric pixels as outlets — OCN_400_Allout","text":"network built 400x400 lattice obtained executing set.seed(8); create_OCN(400, 400, nOutlet = \"\", cellsize = 50).","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_400_Allout.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example of OCN with all perimetric pixels as outlets — OCN_400_Allout","text":"","code":"data(OCN_400_Allout)"},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_400_Allout.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example of OCN with all perimetric pixels as outlets — OCN_400_Allout","text":"list. See create_OCN documentation details.","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_400_T_hot.html","id":null,"dir":"Reference","previous_headings":"","what":"Example of single-outlet OCN — OCN_400_T_hot","title":"Example of single-outlet OCN — OCN_400_T_hot","text":"network built 400x400 lattice obtained executing set.seed(7); create_OCN(400, 400, typeInitialState = \"T\", coolingRate = 0.5, initialNoCoolingPhase = 0.1, cellsize = 50).","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_400_T_hot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example of single-outlet OCN — OCN_400_T_hot","text":"","code":"data(OCN_400_T_hot)"},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_400_T_hot.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example of single-outlet OCN — OCN_400_T_hot","text":"list. See create_OCN documentation details.","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_500_PB_hot.html","id":null,"dir":"Reference","previous_headings":"","what":"Example of single-outlet OCN with periodic boundaries — OCN_500_PB_hot","title":"Example of single-outlet OCN with periodic boundaries — OCN_500_PB_hot","text":"network built 500x500 lattice obtained executing set.seed(10); create_OCN(500, 500, periodicBoundaries = TRUE, coolingRate = 0.5, initialNoCoolingPhase = 0.1, cellsize = 50).","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_500_PB_hot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example of single-outlet OCN with periodic boundaries — OCN_500_PB_hot","text":"","code":"data(OCN_500_PB_hot)"},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_500_PB_hot.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example of single-outlet OCN with periodic boundaries — OCN_500_PB_hot","text":"list. See create_OCN documentation details.","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_500_hot.html","id":null,"dir":"Reference","previous_headings":"","what":"Example of single-outlet OCN — OCN_500_hot","title":"Example of single-outlet OCN — OCN_500_hot","text":"network built 500x500 lattice obtained executing set.seed(9); create_OCN(500, 500, outletPos = 100, outletSide = \"E\", coolingRate = 0.5, initialNoCoolingPhase = 0.1, cellsize = 50, nIter = 50*500*500).","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_500_hot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example of single-outlet OCN — OCN_500_hot","text":"","code":"data(OCN_500_hot)"},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_500_hot.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example of single-outlet OCN — OCN_500_hot","text":"list. See create_OCN documentation details.","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_rect1.html","id":null,"dir":"Reference","previous_headings":"","what":"Example of single-outlet OCN — OCN_rect1","title":"Example of single-outlet OCN — OCN_rect1","text":"network built 450x150 lattice obtained executing set.seed(3); create_OCN(450, 150).","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_rect1.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example of single-outlet OCN — OCN_rect1","text":"","code":"data(OCN_rect1)"},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_rect1.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example of single-outlet OCN — OCN_rect1","text":"list. See create_OCN documentation details.","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_rect2.html","id":null,"dir":"Reference","previous_headings":"","what":"Example of single-outlet OCN — OCN_rect2","title":"Example of single-outlet OCN — OCN_rect2","text":"network built 150x450 lattice obtained executing set.seed(3); create_OCN(150, 450).","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_rect2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example of single-outlet OCN — OCN_rect2","text":"","code":"data(OCN_rect2)"},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_rect2.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example of single-outlet OCN — OCN_rect2","text":"list. See create_OCN documentation details.","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_to_SSN.html","id":null,"dir":"Reference","previous_headings":"","what":"Transform OCN into SSN object — OCN_to_SSN","title":"Transform OCN into SSN object — OCN_to_SSN","text":"Function transforms OCN SpatialStreamNetwork object. analogous function  createSSN package SSN.","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_to_SSN.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transform OCN into SSN object — OCN_to_SSN","text":"","code":"OCN_to_SSN(OCN, level, obsDesign, obsSites, predDesign,    predSites, path, randomAllocation = FALSE, importToR = FALSE)"},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_to_SSN.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transform OCN into SSN object — OCN_to_SSN","text":"OCN List produced aggregate_OCN. level Aggregation level OCN converted SpatialStreamNetwork object.  must equal either \"FD\", \"RN\" \"AG\". obsDesign argument name createSSN. Note length argument design function must equal OCN$nOutlet. one obsDesign obsSites must specified. obsSites Identifier nodes aggregation level observation sites  located. one obsDesign obsSites must specified. predDesign argument name createSSN. Note , design function specified, length argument must equal OCN$nOutlet. predSites Identifier nodes aggregation level prediction sites  located. predDesign predSites optional, specified. path argument name createSSN. randomAllocation Logical. FALSE, observation prediction nodes (obsSites predSites specified, respectively) located exact position corresponding nodes. TRUE, located random position along edge departing selected nodes. importToR argument name createSSN.","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_to_SSN.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Transform OCN into SSN object — OCN_to_SSN","text":"SpatialStreamNetwork object importToR TRUE, otherwise NULL.","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_to_SSN.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Transform OCN into SSN object — OCN_to_SSN","text":"generated SpatialStreamNetwork object consists OCN$nOutlet networks. Note  error thrown , selected aggregation level, least one networks degenerate (.e. less two nodes). typically case OCNs generated option  nOutlet = \"\". OCN$periodicBoundaries == FALSE, nodes' locations SpatialStreamNetwork object  given lattice coordinates (.e. OCN$level$X, OCN$level$Y);  OCN$periodicBoundaries == TRUE, real coordinates used (.e. defined  OCN$FD$Xdraw, OCN$FD$Ydraw, see landscape_OCN).","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_to_SSN.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Transform OCN into SSN object — OCN_to_SSN","text":"","code":"# transform a 20x20 single-outlet OCN (aggregated at the AG level) # into a SSN object and plot it OCN <- aggregate_OCN(landscape_OCN(OCN_20), thrA = 4) ssn1 <- OCN_to_SSN(OCN, \"AG\", obsDesign = SSN::poissonDesign(10),  path=paste(tempdir(),\"/OCN.ssn\", sep = \"\"), importToR = TRUE) #> Warning: OGR support is provided by the sf and terra packages among others #> Warning: OGR support is provided by the sf and terra packages among others #> Warning: OGR support is provided by the sf and terra packages among others #> Warning: OGR support is provided by the sf and terra packages among others plot(ssn1)   # \\donttest{ # 1) create a 50x50 OCN with two outlets and periodic boundaries;  set.seed(1) OCN <- create_OCN(50, 50, nOutlet = 2, outletSide = c(\"S\", \"N\"),     outletPos = c(1, 50), periodicBoundaries = TRUE) #> create_OCN is running... #> Estimated duration: 16.71 seconds  #> Note that the above estimate is only based on the choice of parameters dimX, dimY and nIter, and not on processor performance. #>  # aggregate the OCN; OCN <- aggregate_OCN(landscape_OCN(OCN)) # transform it into a SSN object aggregated at the RN level; ssn2 <- OCN_to_SSN(OCN, \"RN\", obsDesign = SSN::binomialDesign(c(10, 10)),     path = paste(tempdir(),\"/OCN2.ssn\", sep = \"\"), importToR = TRUE) #> Warning: OGR support is provided by the sf and terra packages among others #> Warning: OGR support is provided by the sf and terra packages among others #> Warning: OGR support is provided by the sf and terra packages among others #> Warning: OGR support is provided by the sf and terra packages among others # and plot the SSN object; it is constituted by two networks, # and nodes' coordinates are the \"real\" ones   old.par <- par(no.readonly = TRUE) par(mai = c(1, 1, 1, 1)) plot(ssn2, xlab = \"X\", ylab = \"Y\")  par(old.par) # }  # 2) An OCN with 3 outlets transformed into a SSN, with obsSites # attributed at given locations set.seed(2) OCN <- aggregate_OCN(landscape_OCN(create_OCN(20, 20, nOutlet = 3)), thrA = 4) obsSites <- c(1, 7, 12, 15, 21, 28, 34, 41, 50) ssn3 <- OCN_to_SSN(OCN, \"AG\", obsSites=obsSites,                      path = paste(tempdir(),\"/OCN3.ssn\", sep = \"\"), importToR = TRUE) #> Warning: OGR support is provided by the sf and terra packages among others #> Warning: OGR support is provided by the sf and terra packages among others #> Warning: OGR support is provided by the sf and terra packages among others #> Warning: OGR support is provided by the sf and terra packages among others draw_thematic_OCN(OCN) points(OCN$AG$X[obsSites], OCN$AG$Y[obsSites])  plot(ssn3)"},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_to_igraph.html","id":null,"dir":"Reference","previous_headings":"","what":"Transform OCN into igraph object — OCN_to_igraph","title":"Transform OCN into igraph object — OCN_to_igraph","text":"Function transforms OCN igraph object.","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_to_igraph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transform OCN into igraph object — OCN_to_igraph","text":"","code":"OCN_to_igraph(OCN, level)"},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_to_igraph.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transform OCN into igraph object — OCN_to_igraph","text":"OCN List produced aggregate_OCN. level Aggregation level OCN converted igraph object.  must equal either \"FD\", \"RN\" \"AG\".","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_to_igraph.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Transform OCN into igraph object — OCN_to_igraph","text":"igraph object.","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/OCN_to_igraph.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Transform OCN into igraph object — OCN_to_igraph","text":"","code":"# 1) transform a 20x20 OCN, at the AG level, into a graph object  OCN <- aggregate_OCN(landscape_OCN(OCN_20), thrA = 4) g <- OCN_to_igraph(OCN, level = \"AG\") plot(g, layout = matrix(c(OCN$AG$X,OCN$AG$Y), ncol = 2, nrow = OCN$AG$nNodes))"},{"path":"https://lucarraro.github.io/OCNet/reference/OCNet-package.html","id":null,"dir":"Reference","previous_headings":"","what":"Create and analyze Optimal Channel Networks. — OCNet-package","title":"Create and analyze Optimal Channel Networks. — OCNet-package","text":"package allows generation analysis synthetic river network analogues, called Optimal Channel Networks (OCNs).","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/OCNet-package.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Create and analyze Optimal Channel Networks. — OCNet-package","text":"Rinaldo, ., Rigon, R., Banavar, J. R., Maritan, ., & Rodriguez-Iturbe, . (2014). Evolution selection river networks: Statics, dynamics, complexity. Proceedings National Academy Sciences United States America, 111(7), 2417-2424. doi:10.1073/pnas.1322700111 Carraro, L., Bertuzzo, E., Fronhofer, E. ., Furrer, R., Gounand, ., Rinaldo, ., & Altermatt, F. (2020). Generation application river network analogues use ecology evolution. Ecology Evolution, 10(14), 7537-7550. doi:10.1002/ece3.6479 Carraro, L., & Altermatt, F. (2022). Optimal channel networks accurately model ecologically-relevant geomorphological features branching river networks. Communications Earth Environment, 3(1) doi:10.1038/s43247-022-00454-1","code":""},{"path":[]},{"path":"https://lucarraro.github.io/OCNet/reference/OCNet-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create and analyze Optimal Channel Networks. — OCNet-package","text":"Luca Carraro (luca.carraro@hotmail.), Florian Altermatt, Emanuel . Fronhofer, Reinhard Furrer, Isabelle Gounand, Andrea Rinaldo, Enrico Bertuzzo","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/aggregate_OCN.html","id":null,"dir":"Reference","previous_headings":"","what":"Aggregate an Optimal Channel Network — aggregate_OCN","title":"Aggregate an Optimal Channel Network — aggregate_OCN","text":"Function , given OCN, builds network river network (RN), aggregated (AG), subcatchment (SC), catchment (CM) levels.","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/aggregate_OCN.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Aggregate an Optimal Channel Network — aggregate_OCN","text":"","code":"aggregate_OCN(OCN, thrA = 0.002 * OCN$FD$nNodes *   OCN$cellsize^2, streamOrderType = \"Strahler\", maxReachLength = Inf,   breakpoints = NULL, displayUpdates = FALSE)"},{"path":"https://lucarraro.github.io/OCNet/reference/aggregate_OCN.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Aggregate an Optimal Channel Network — aggregate_OCN","text":"OCN List produced landscape_OCN. thrA Threshold value drainage area used derive aggregated network. thrA = 0, aggregation performed:  every FD node also node RN AG levels. case, function aggregate_OCN can still used compute statistics  OCN$AG$streamOrder. streamOrderType \"Strahler\", Strahler stream order computed; \"Shreve\", Shreve stream order computed. maxReachLength Maximum reach length allowed (planar units). path length channel head downstream confluence  higher maxReachLength, reach starting channel head length maxReachLength, next downstream  pixel considered new channel head, new reach departs. breakpoints Indices additional nodes RN level also nodes AG level (beyond source, confluence, outlet nodes  AG nodes determined via maxReachLength). determine indices, preliminary run aggregate_OCN thrA  required (see example 3). displayUpdates Logical. State updates printed console landscape_OCN runs.","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/aggregate_OCN.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Aggregate an Optimal Channel Network — aggregate_OCN","text":"list contains objects contained OCN, addition objects listed .  New sublists RN, AG, SC, containing variables corresponding aggregation levels, created. Refer section 4.2 vignette detailed explanation values OCN$XX$toYY, XX YY two random aggregation levels. FD$toRN Vector (length OCN$FD$nNodes) whose values equal 0 FD node node RN level.  FD$toRN[] != 0, FD$toRN[] index RN level node whose index FD level . Thereby,  FD$toRN[] = j implies RN$toFD[j] = . FD$toSC Vector (length OCN$FD$nNodes) SC indices nodes FD level.  OCN$FD$toSC[] = j, %% OCN$SC$toFD[[j]] = TRUE. RN$Vector (length RN$nNodes) containing drainage area values RN nodes (square planar units). RN$W Adjacency matrix (RN$nNodes RN$nNodes) RN level. spam  object. RN$downNode Vector (length RN$nNodes) representing adjacency matrix RN level vector form:  RN$downNode[] = j RN$W[,j] = 1. o outlet node, RN$downNode[o] = 0. RN$drainageDensity Drainage density river network, calculated total length river network divided area lattice. expressed planar units^(-1). RN$leng Vector (length RN$nNodes) lengths edges departing nodes RN level. values equal either 0 (corresponding node outlet), OCN$cellsize (corresponding flow direction horizontal/vertical), sqrt(2)*OCN$cellsize (diagonal flow). RN$nNodes Number nodes RN level. RN$nUpstream Vector (length RN$nNodes) providing number nodes upstream node (node included). RN$outlet Vector (length OCN$FD$nOutlet) indices nodes RN level corresponding outlets. RN$Slope Vector (length RN$nNodes) pixel slopes RN level. RN$toAG Vector (length RN$nNodes) whose values equal 0 RN node node AG level.  RN$toAG[] != 0, RN$toAG[] index AG level node whose index RN level . Thereby,  RN$toAG[] = j implies AG$toRN[j] = . RN$toAGReach Vector (length RN$nNodes) identifying edge (reach) RN nodes belong. RN$toAGReach[] = j,  RN node belongs edge departing AG node j (implies may correspond AG node j .) RN$toFD Vector (length RN$nNodes) indices FD level nodes belonging RN level. RN$toFD[] = j implies OCN$FD$toRN[j] = . RN$toCM Vector (length RN$nNodes) catchment index values RN node. Example: RN$toCM[] = j node drains outlet whose location defined outletSide[j], outletPos[j]. RN$upstream List (length RN$nNodes) whose object vector (length RN$nUpstream[]) containing  indices nodes upstream node (including ). RN$X, RN$Y Vectors (length RN$nNodes) X, Y coordinates nodes RN level. RN$Z Vector (length RN$nNodes) Z coordinates nodes RN level. AG$Vector (length AG$nNodes) containing drainage area values nodes AG level.  channel head, AG$[RN$toAG[]] = RN$[]. AG$AReach Vector (length AG$nNodes) containing drainage area values computed accounting areas drained edges departing AG nodes.  words, AG$AReach[] equal drainage area last downstream node belonging reach departs  (namely AG$AReach[] = max(RN$[RN$toAG == ])). AG$W Adjacency matrix (AG$nNodes AG$nNodes) AG level. spam object. AG$downNode Vector (length AG$nNodes) representing adjacency matrix AG level vector form:  AG$downNode[] = j AG$W[,j] = 1. o outlet node, AG$downNode[o] = 0. AG$leng Vector (length AG$nNodes) lengths edges departing nodes AG level. Note AG$leng[] = sum(RN$leng[RN$toAG == ]). o outlet node (.e. (o %% AG$outlet) = TRUE), AG$leng[] = 0. AG$nNodes Number nodes resulting aggregation process. AG$nUpstream Vector (length AG$nNodes) providing number nodes (AG level) upstream node (node included). AG$outlet Vector (length OCN$FD$nOutlet) indices outlet nodes, .e. nodes whose AG$downNode value 0. AG$slope Vector (length AG$nNodes) slopes AG level. represents (weighted) average slope edges departing nodes.  outlet node (.e. (%% AG$outlet) = TRUE), AG$slope[] = NaN. AG$streamOrder Vector (length AG$nNodes) stream order values node. streamOrderType = \"Strahler\",  Strahler stream order computed. streamOrderType = \"Shreve\", Shreve stream order computed. AG$upstream List (length AG$nNodes) whose object vector (length AG$nUpstream[]) containing  indices nodes (AG level) upstream node (including ). AG$toFD Vector length AG$nNodes) indices FD level nodes belonging AG level. AG$toFD[] = j implies OCN$FD$toAG[j] = . AG$ReachToFD List (length AG$nNodes) whose object vector indices FD nodes constituting edge  departing node . AG$toRN Vector length AG$nNodes) indices RN level nodes belonging AG level. AG$toRN[] = j implies OCN$FD$toRN[j] = . AG$ReachToRN List (length AG$nNodes) whose object vector indices RN nodes constituting edge  departing node . AG$toCM Vector (length AG$nNodes) catchment index values AG node. Example: AG$toCM[] = j node drains outlet whose location defined outletSide[j], outletPos[j]. AG$X, AG$Y Vectors (length AG$nNodes) X, Y coordinates (planar units) nodes AG level.  correspond X, Y coordinates nodes constituting upstream tips reaches.  j AG$X[] == RN$X[j] AG$Y[] == RN$Y[j], AG$[] = RN$[j]. AG$XReach, AG$YReach Vector (length AG$nNodes) X, Y coordinates (planar units) downstream tips reaches.  j AG$XReach[] == RN$X[j] AG$YReach[] == RN$Y[j], AG$AReach[] = RN$[j].  o outlet node, AG$XReach = NaN, AG$YReach = NaN. AG$Z Vector (length AG$nNodes) elevation values (elevational units) nodes AG level.  correspond elevations nodes constituting upstream tips reaches. AG$ZReach Vector (length AG$nNodes) Z coordinates (elevational units) downstream tips reaches. o outlet node, AG$ZReach = NaN. SC$ALocal Vector (length SC$nNodes) values subcatchment area, number FD pixels  (multiplied OCN$FD$cellsize^2) constitutes subcatchment. o outlet node, ALocal[o] = 0. SC$W Adjacency matrix (SC$nNodes SC$nNodes) subcatchment level. Two subcatchments connected share border.  Note flow connection. Unlike adjacency matrices levels FD, RN, AG, matrix symmetric. spam object. o outlet node, SC$W[o,] SC$W[,o] contain zeros (.e., o unconnected nodes). SC$nNodes Number subcatchments lattice partitioned. nOutlet = 1, SC$nNodes = AG$nNodes.  multiple outlets present, SC$nNodes might greater AG$nNodes case catchments drainage area lower thrA.  case, indices AG$nNodes + 1 SC$nNodes identify subcatchment corresponding AG node. SC$toFD List (length SC$nNodes) whose object vector indices FD pixels constituting subcatchment . SC$X, SC$Y Vectors (length SC$nNodes) X, Y coordinates (planar units) subcatchment centroids. SC$Z Vector (length SC$nNodes) average subcatchment elevation (elevational units). Finally, thrA added list.","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/aggregate_OCN.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Aggregate an Optimal Channel Network — aggregate_OCN","text":"Note node (corresponding edge exiting , case non-outlet nodes) AG level corresponds  subcatchment SC level shares index: instance, SC$toFD[] contains elements  AG$toFD[] (, indices pixels FD level constitute edge departing node  also part subcatchment ).","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/aggregate_OCN.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Aggregate an Optimal Channel Network — aggregate_OCN","text":"","code":"# 1) aggregate a 20x20 OCN by imposing thrA = 4 OCN <- aggregate_OCN(landscape_OCN(OCN_20), thrA = 4)  # \\donttest{ # 2) explore the effects of thrA and maxReachLength on a large OCN OCN <- landscape_OCN(OCN_250_T) # it takes some seconds OCN_a <- aggregate_OCN(OCN, thrA = 200) # it takes some seconds OCN_b <- aggregate_OCN(OCN, thrA = 1000) # it takes some seconds OCN_c <- aggregate_OCN(OCN, thrA = 1000, maxReachLength = 20) # it takes some seconds  old.par <- par(no.readonly = TRUE) par(mfrow = c(1,3)) draw_subcatchments_OCN(OCN_a) points(OCN_a$AG$X, OCN_a$AG$Y, pch = 19, col = \"#0044bb\")  title(paste(\"No. AG nodes = \", as.character(OCN_a$AG$nNodes),     sep=\"\")) draw_subcatchments_OCN(OCN_b) points(OCN_b$AG$X, OCN_b$AG$Y, pch = 19, col = \"#0044bb\")  title(paste(\"No. AG nodes = \", as.character(OCN_b$AG$nNodes),     sep=\"\")) draw_subcatchments_OCN(OCN_c) points(OCN_c$AG$X, OCN_c$AG$Y, pch = 19, col = \"#0044bb\")  title(paste(\"No. AG nodes = \", as.character(OCN_c$AG$nNodes),     sep=\"\"))  par(old.par) # }  # 3) use of breakpoints OCN <- aggregate_OCN(landscape_OCN(OCN_20), thrA = 5) draw_thematic_OCN(OCN, drawNodes=TRUE)  # add an AG node downstream of node 1 at AG level new_node_RN <- OCN$RN$downNode[OCN$AG$toRN[1]] OCN2 <- aggregate_OCN(landscape_OCN(OCN_20), thrA = 5, breakpoints = new_node_RN) draw_thematic_OCN(OCN2, drawNodes = TRUE) points(OCN$RN$X[new_node_RN], OCN$RN$Y[new_node_RN],    pch = 19, col = \"red\") # this node has been added"},{"path":"https://lucarraro.github.io/OCNet/reference/continue_OCN.html","id":null,"dir":"Reference","previous_headings":"","what":"Perform OCN Search Algorithm on an Existing OCN — continue_OCN","title":"Perform OCN Search Algorithm on an Existing OCN — continue_OCN","text":"Function performs OCN search algorithm existing OCN.","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/continue_OCN.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Perform OCN Search Algorithm on an Existing OCN — continue_OCN","text":"","code":"continue_OCN(OCN,nNewIter, coolingRate=NULL, initialNoCoolingPhase=0,  displayUpdates=1, showIntermediatePlots=FALSE, thrADraw=NULL,  easyDraw=NULL, nUpdates=50)"},{"path":"https://lucarraro.github.io/OCNet/reference/continue_OCN.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Perform OCN Search Algorithm on an Existing OCN — continue_OCN","text":"OCN Optimal Channel Network (generated create_OCN). nNewIter Number iterations OCN search algorithm performs. coolingRate Parameter function used describe temperature simulated annealing algorithm. See create_OCN. NULL, set equal last element OCN$coolingRate. initialNoCoolingPhase Parameter function used describe temperature simulated annealing algorithm. See create_OCN. nUpdates Number updates given OCN search process (effective (displayUpdates,showIntermediatePlots)=TRUE.). showIntermediatePlots TRUE, OCN plot updated nUpdates times OCN search process. Note , large lattices, showIntermediatePlots = TRUE might slow search process considerably (especially easyDraw = FALSE). thrADraw Threshold drainage area value used display network (effective showIntermediatePlots = TRUE). easyDraw Logical. TRUE, whole network displayed (showIntermediatePlots = TRUE), pixels drainage area lower thrADraw displayed light gray. FALSE, pixels drainage area greater equal thrADraw displayed. Default FALSE dimX*dimY <= 40000, TRUE otherwise. Note setting easyDraw = FALSE large networks might slow process considerably. displayUpdates State updates printed console OCN search algorithm runs. 0 update given. 1 estimate duration given (dimX*dimY > 1000, otherwise update given). 2 Progress updates given. number controlled nUpdates","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/continue_OCN.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Perform OCN Search Algorithm on an Existing OCN — continue_OCN","text":"list analogous input OCN. Note , unlike create_OCN, OCN$coolingRate OCN$initialNoCoolingPhase now vectors (length equal number times continue_OCN performed OCN, plus one) store full sequence coolingRate, initialNoCoolingPhase used generate OCN. Additionally, vector OCN$nIterSequence provided, entries equal number iterations performed successive application create_OCN continue_OCN. OCN$nIter = sum(OCN$nIterSequence).","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/continue_OCN.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Perform OCN Search Algorithm on an Existing OCN — continue_OCN","text":"","code":"set.seed(1) OCN_a <- create_OCN(20, 20, nIter = 10000) set.seed(1) OCN_b <- create_OCN(20, 20, nIter = 5000) OCN_b <- continue_OCN(OCN_b, nNewIter = 5000)  old.par <- par(no.readonly = TRUE) par(mfrow=c(1,2)) draw_simple_OCN(OCN_a) draw_simple_OCN(OCN_b) # the two OCNs are equal  par(old.par)"},{"path":"https://lucarraro.github.io/OCNet/reference/create_OCN.html","id":null,"dir":"Reference","previous_headings":"","what":"Create an Optimal Channel Network — create_OCN","title":"Create an Optimal Channel Network — create_OCN","text":"Function performs OCN search algorithm rectangular lattice creates OCN flow direction (FD) level.","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/create_OCN.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create an Optimal Channel Network — create_OCN","text":"","code":"create_OCN(dimX, dimY, nOutlet = 1, outletSide = \"S\",   outletPos = round(dimX/3), periodicBoundaries = FALSE,   typeInitialState = NULL, flowDirStart = NULL, expEnergy = 0.5,   cellsize = 1, xllcorner = 0.5 * cellsize, yllcorner = 0.5 *   cellsize, nIter = 40 * dimX * dimY, nUpdates = 50,   initialNoCoolingPhase = 0, coolingRate = 1,   showIntermediatePlots = FALSE, thrADraw = 0.002 * dimX * dimY *   cellsize^2, easyDraw = NULL, saveEnergy = FALSE, saveExitFlag = FALSE,   saveN8 = FALSE, saveN4 = FALSE, displayUpdates = 1)"},{"path":"https://lucarraro.github.io/OCNet/reference/create_OCN.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create an Optimal Channel Network — create_OCN","text":"dimX Longitudinal dimension lattice (number pixels). dimY Latitudinal dimension lattice (number pixels). nOutlet Number outlets. nOutlet = \"\", border pixels set outlets. outletSide Side lattice outlet(s) /placed.  vector characters, whose allowed values \"N\" (northern side), \"E\", \"S\", \"W\". length must equal nOutlet. outletPos Vector positions outlets within sides specified outletSide.  outletSide[] = \"N\" \"S\", outletPos[] must natural number interval 1:dimX;  outletSide[] = \"W\" \"E\", outletPos[] must natural number interval 1:dimY.  nOutlet > 1 specified user outletSide, outletPos , number outlets equal  nOutlet randomly drawn among border pixels. length must equal nOutlet. periodicBoundaries TRUE, periodic boundaries applied. case, lattice planar equivalent torus. typeInitialState Configuration initial state network. Possible values: \"\" (representing valley);  \"T\" (T-shaped drainage pattern); \"V\" (V-shaped drainage pattern); \"H\" (hip roof). Default value set \"\", unless nOutlet = \"\", default \"H\".  See Details explanation initial network state multiple outlet case. flowDirStart Matrix (dimY dimX) custom initial flow directions.  Possible entries flowDirStart natural numbers 1 8, indicating direction flow one cell neighbouring one.  Key follows: 1 +1 column 2 -1 row, +1 column 3 -1 row 4 -1 row, -1 column 5 -1 column 6 +1 row, -1 column 7 +1 row 8 +1 row, +1 column expEnergy Exponent functional sum(^expEnergy) minimized OCN search algorithm. cellsize Size pixel planar units. xllcorner Longitudinal coordinate lower-left pixel. yllcorner Latitudinal coordinate lower-left pixel. nIter Number iterations OCN search algorithm. nUpdates Number updates given OCN search process (effective (displayUpdates,showIntermediatePlots)=TRUE.). initialNoCoolingPhase, coolingRate Parameters function used describe temperature simulated annealing algorithm. See details. showIntermediatePlots TRUE, OCN plot updated nUpdates times OCN search process. Note , large lattices, showIntermediatePlots = TRUE might slow search process considerably (especially easyDraw = FALSE). thrADraw Threshold drainage area value used display network (effective showIntermediatePlots = TRUE). easyDraw Logical. TRUE, whole network displayed (showIntermediatePlots = TRUE), pixels drainage area lower thrADraw displayed light gray. FALSE, pixels drainage area greater equal thrADraw displayed. Default FALSE dimX*dimY <= 40000, TRUE otherwise. Note setting easyDraw = FALSE large networks might slow process considerably. saveEnergy TRUE, energy saved (see Value definition). saveExitFlag TRUE, exitFlag saved (see Value definition). saveN8 TRUE, adjacency matrix relative 8-nearest-neighbours connectivity saved. saveN4 TRUE, adjacency matrix relative 4-nearest-neighbours connectivity saved. displayUpdates State updates printed console OCN search algorithm runs. 0 update given. 1 estimate duration given (dimX*dimY > 1000, otherwise update given). 2 Progress updates given. number controlled nUpdates","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/create_OCN.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create an Optimal Channel Network — create_OCN","text":"list whose objects listed . Variables define network FD level wrapped sublist FD. Adjacency matrices describing 4- 8- nearest-neighbours connectivity among pixels contained lists N4 N8, respectively. FD$Vector (length dimX*dimY) containing drainage area values FD pixels (square planar units). FD$W Adjacency matrix (dimX*dimY dimX*dimY) FD level.  spam object. FD$downNode Vector (length dimX*dimY) representing adjacency matrix FD level vector form:  FD$downNode[] = j FD$W[,j] = 1. o outlet pixel,  FD$downNode[o] = 0. FD$X (FD$Y) Vector (length dimX*dimY) containing X (Y) coordinate values FD pixels. FD$nNodes Number nodes FD level (equal dimX*dimY). FD$outlet Vector (length nOutlet) indices pixels FD level corresponding outlets. FD$perm Vector (length dimX*dimY) representing permutation FD pixels: perm[((perm==) - FD$[] + 1):(perm==)] gives indices pixels drain pixel . energyInit Initial energy value. energy Vector (length nIter) energy values stage OCN search algorithm (present saveEnergy = TRUE). exitFlag Vector (length nIter) showing outcome rewiring process (present saveExitFlag = TRUE). entries can assume one following values: 0 Rewiring accepted. 1 Rewiring accepted (lower energy according acceptance probability simulated annealing algorithm). 2 Rewiring invalid  loop graph generated, therefore network longer direct acyclic graph. 3 Rewiring invalid cross-flow. means , example, 2x2 cluster pixel, southwestern (SW) corner drains NE one, SE drains NW. Although circumstance imply presence loop graph, physical meaning thereby forbidden. N4$W Adjacency matrix (dimX*dimY dimX*dimY) describes 4-nearest-neighbours connectivity  pixels: N4$W[,j] = 1 pixel j shares edge , null otherwise.  saved saveN4 = TRUE. N8$W Adjacency matrix (dimX*dimY dimX*dimY) describes 8-nearest-neighbours connectivity  pixels: N8$W[,j] = 1 pixel j shares edge vertex , null otherwise.  saved saveN8 = TRUE. Finally, dimX, dimY, cellsize, nOutlet, periodicBoundaries, expEnergy,  coolingRate, typeInitialState, nIter, xllcorner, yllcorner passed list included input  (except nOutlet = \"\" converted 2*(dimX + dimY - 2)).","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/create_OCN.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create an Optimal Channel Network — create_OCN","text":"Simulated annealing temperature.  function expresses temperature simulated annealing process follows: <= initialNoCoolingPhase*nIter: Temperature[] = Energy[1] initialNoCoolingPhase*nIter < <= nIter: Temperature[] = Energy[1]*(-coolingRate*(- InitialNocoolingPhase*nIter)/nNodes) index current iteration Energy[1] = sum(^expEnergy), denoting   vector drainage areas corresponding initial state network. According simulated annealing   principle, new network configuration obtained iteration accepted probability equal   exp((Energy[] - Energy[-1])/Temperature[]) Energy[] < Energy[-1].   ensure convergence, recommended use coolingRate values 0.5 10 initialNoCoolingPhase <= 0.3.   Low coolingRate high initialNoCoolingPhase values cause network configuration depart significantly initial state.  coolingRate < 0.5 initialNoCoolingPhase > 0.1 used, suggested increase nIter respect default value order guarantee convergence. Initial network state.  nOutlet > 1, initial state applied regards outlet located outletSide[1], outletPos[1].  Subsequently, outlets, drainage pattern altered within region maximum size 0.5*dimX 0.25*dimY outlets located eastern western borders lattice,  0.25*dimX 0.5*dimY outlets located southern northern borders lattice. midpoint long size regions coincides outlet stake. Within regions, \"\"-type drainage pattern produced typeInitialState = \"\" \"T\"; \"V\"-type drainage pattern produced typeInitialState = \"V\";  action performed typeInitialState = \"H\". Note typeInitialState = \"H\" recommended choice large nOutlet. Suggestions creating \"fancy\" OCNs.  order generate networks spanning realistic, non-rectangular catchment domain (\"real-shape\" view provided draw_contour_OCN), convenient  use option periodicBoundaries = TRUE impose least couple diagonally adjacent outlets two opposite sides, example nOutlet = 2, outletSide = c(\"S\", \"N\"), outletPos = c(1, 2).  See also OCN_300_4out_PB_hot. Note , OCN search algorithm stochastic process, successful generation \"fancy\" OCN guaranteed: indeed, possible final outcome  network () pixels drain towards one two outlets, hence outlet surrounded (\"real-shape\" view) pixels drains. Note , order hinder occurrence, two pixels along lattice perimeter next outlet bound drain towards outlet. order create network spanning \"pear-shaped\" catchment (namely width area spanned direction orthogonal main stem diminishes downstream, coincides river width outlet), convenient use option nOutlet = \"\" (value periodicBoundaries irrelevant) pick single catchment (presumably one rather large catchment area, see value OCN$CM$generated landscape_OCN) among many generated. Note possible predict area spanned catchment priori. obtain catchment whose size rather large compared size lattice  OCN generated, convenient set typeInitialState = \"\" pick catchment largest area (landscape_OCN must run). default temperature schedule simulated annealing process generally adequate generating OCN resemble initial network state size lattice large (say, dimX*dimY <= 40000). dimX*dimY > 40000, might convenient make use \"warmer\" temperature schedule (example, setting coolingRate = 0.5 initialNoCoolingPhase = 0.1; see also package vignette) /increase nIter respect default value. Note suggestions pertain aesthetics final OCN; default temperature schedule nIter calibrated ensure convergence OCN (.e. achievement local minimum Energy, save reasonable threshold) also lattices larger dimX*dimY = 40000.","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/create_OCN.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create an Optimal Channel Network — create_OCN","text":"","code":"# 1) creates and displays a single outlet 20x20 OCN with default options set.seed(1) OCN_a <- create_OCN(20, 20) draw_simple_OCN(OCN_a)   # \\donttest{ # 2) creates and displays a 2-outlet OCNs with manually set outlet location,  # and a 4-outlet OCNs with random outlet position. set.seed(1) old.par <- par(no.readonly = TRUE) par(mfrow=c(1,2)) OCN_b1 <- create_OCN(30, 30, nOutlet = 2, outletSide = c(\"N\", \"W\"), outletPos = c(15, 12)) OCN_b2 <- create_OCN(30, 30, nOutlet = 4) draw_simple_OCN(OCN_b1) title(\"2-outlet OCN\") draw_simple_OCN(OCN_b2) title(\"4-outlet OCN\")  par(old.par) # }  if (FALSE) { # 3) generate 3 single-outlet OCNs on the same (100x100) domain starting from different  # initial states, and show 20 intermediate plots and console updates. set.seed(1) OCN_V <- create_OCN(100, 100, typeInitialState = \"V\", showIntermediatePlots = TRUE,      nUpdates = 20, displayUpdates = 2) OCN_T <- create_OCN(100, 100, typeInitialState = \"T\", showIntermediatePlots = TRUE,      nUpdates = 20, displayUpdates = 2) OCN_I <- create_OCN(100, 100, typeInitialState = \"I\", showIntermediatePlots = TRUE,      nUpdates = 20, displayUpdates = 2) }  if (FALSE) { # 4) generate a 2-outlet OCN and show intermediate plots. Note that different colors are used  # to identify the two networks  (all pixels are colored because thrADraw = 0). set.seed(1) OCN <- create_OCN(150, 70, nOutlet = 2, outletPos = c(1, 150), outletSide = c(\"S\", \"N\"),     typeInitialState = \"V\", periodicBoundaries = TRUE,      showIntermediatePlots = TRUE, thrADraw = 0) # The resulting networks have an irregular contour, and their outlets are located on the contour: draw_contour_OCN(landscape_OCN(OCN)) }"},{"path":"https://lucarraro.github.io/OCNet/reference/create_general_contour_OCN.html","id":null,"dir":"Reference","previous_headings":"","what":"Create an Optimal Channel Network on a general contour — create_general_contour_OCN","title":"Create an Optimal Channel Network on a general contour — create_general_contour_OCN","text":"Function performs OCN search algorithm general contour creates OCN flow direction (FD) level.","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/create_general_contour_OCN.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create an Optimal Channel Network on a general contour — create_general_contour_OCN","text":"","code":"create_general_contour_OCN(flowDirStart, expEnergy = 0.5,   cellsize = 1, xllcorner = 0.5 * cellsize, yllcorner = 0.5 *   cellsize, nIter = NULL, nUpdates = 50,   initialNoCoolingPhase = 0, coolingRate = 1,   showIntermediatePlots = FALSE, thrADraw = NULL,    easyDraw = NULL, saveEnergy = FALSE, saveExitFlag = FALSE,   displayUpdates = 1)"},{"path":"https://lucarraro.github.io/OCNet/reference/create_general_contour_OCN.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create an Optimal Channel Network on a general contour — create_general_contour_OCN","text":"flowDirStart Matrix custom initial flow directions. Cells outside catchment must value equal NaN.  Cells within catchment natural numbers 1 8. Key follows: 1 +1 column 2 -1 row, +1 column 3 -1 row 4 -1 row, -1 column 5 -1 column 6 +1 row, -1 column 7 +1 row 8 +1 row, +1 column expEnergy Exponent functional sum(^expEnergy) minimized OCN search algorithm. cellsize Size pixel planar units. xllcorner Longitudinal (column-wise) coordinate lower-left pixel flowDirStart. yllcorner Latitudinal (row-wise) coordinate lower-left pixel flowDirStart. nIter Number iterations OCN search algorithm. Default 40 times number non-NaN pixels flowDirStart. nUpdates Number updates given OCN search process (effective (displayUpdates,showIntermediatePlots)=TRUE.). initialNoCoolingPhase, coolingRate Parameters function used describe temperature simulated annealing algorithm. See details. showIntermediatePlots TRUE, OCN plot updated nUpdates times OCN search process. Note , large lattices, showIntermediatePlots = TRUE might slow search process considerably (especially easyDraw = FALSE). thrADraw Threshold drainage area value used display network (effective showIntermediatePlots = TRUE). Default value 0.002*cellsize^2*nNodes, nNodes number non-NaN pixels flowDirStart. easyDraw Logical. TRUE, whole network displayed (showIntermediatePlots = TRUE), pixels drainage area lower thrADraw displayed light gray. FALSE, pixels drainage area greater equal thrADraw displayed. Default FALSE dimX*dimY <= 40000, TRUE otherwise. Note setting easyDraw = FALSE large networks might slow process considerably. saveEnergy TRUE, energy saved (see Value definition). saveExitFlag TRUE, exitFlag saved (see Value definition). displayUpdates State updates printed console OCN search algorithm runs. 0 update given. 1 estimate duration given (dimX*dimY > 1000, otherwise update given). 2 Progress updates given. number controlled nUpdates","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/create_general_contour_OCN.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create an Optimal Channel Network on a general contour — create_general_contour_OCN","text":"list create_OCN, reader referred detailed documentation. However, note case dimX dimY equal number columns rows flowDirStart, respectively,  nNodes number non-NaN pixels flowDirStart. Hence, nNodes generally lower dimX*dimY. additionally exported vector FD$toDEM identifies indices pixels landscape/flow direction matrix belong catchment (.e., NaN).","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/create_general_contour_OCN.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create an Optimal Channel Network on a general contour — create_general_contour_OCN","text":"","code":"OCN1 <- create_general_contour_OCN(flowDir, nIter=0) # initial flow directions OCN2 <- create_general_contour_OCN(flowDir) # perform OCN algorithm draw_simple_OCN(OCN1)  draw_simple_OCN(OCN2)"},{"path":"https://lucarraro.github.io/OCNet/reference/create_peano.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Peano network — create_peano","title":"Create Peano network — create_peano","text":"Function creates Peano networks square lattice.","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/create_peano.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create Peano network — create_peano","text":"","code":"create_peano(nIterPeano, outletPos = \"NE\", xllcorner = 1,   yllcorner = 1, cellsize = 1)"},{"path":"https://lucarraro.github.io/OCNet/reference/create_peano.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create Peano network — create_peano","text":"nIterPeano Number iteration Peano scheme. resulting network span domain  size 2^(nIterPeano + 1) 2^(nIterPeano + 1). outletPos Corner outlet located, expressed intercardinal direction.  Possible values \"NE\", \"SE\", \"SW\", \"NW\". xllcorner X coordinate lower-left pixel (expressed planar units). yllcorner Y coordinate lower-left pixel (expressed planar units). cellsize Size pixel (expressed planar units).","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/create_peano.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create Peano network — create_peano","text":"list contains objects produced create_OCN.  , can used input complementary functions package.","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/create_peano.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create Peano network — create_peano","text":"","code":"# 1) create a peano network in a 32x32 square, # use landscape_OCN, aggregate_OCN functions, # and display subcatchment map and map of drainage area peano <- create_peano(4) peano <- aggregate_OCN(landscape_OCN(peano), thrA = 4) old.par <- par(no.readonly = TRUE) par(mfrow=c(1,3)) draw_simple_OCN(peano) title(\"Peano network\") draw_subcatchments_OCN(peano) title(\"Subcatchments\") draw_thematic_OCN(peano$RN$A, peano) title(\"Drainage area at RN level\")  par(old.par)"},{"path":"https://lucarraro.github.io/OCNet/reference/draw_contour_OCN.html","id":null,"dir":"Reference","previous_headings":"","what":"Draw Optimal Channel Network with catchment contours — draw_contour_OCN","title":"Draw Optimal Channel Network with catchment contours — draw_contour_OCN","text":"Function plots real-shaped OCN catchment contours.","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/draw_contour_OCN.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Draw Optimal Channel Network with catchment contours — draw_contour_OCN","text":"","code":"draw_contour_OCN(OCN, thrADraw = 0.002 * OCN$FD$nNodes *   OCN$cellsize^2, exactDraw = TRUE, drawContours = TRUE, colPalRiver = NULL,    colPalCont = \"#000000\", drawOutlets = 0, pch = 15, colPalOut = \"#000000\",   min_lwd = 0.5, max_lwd = 5)"},{"path":"https://lucarraro.github.io/OCNet/reference/draw_contour_OCN.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Draw Optimal Channel Network with catchment contours — draw_contour_OCN","text":"OCN List produced landscape_OCN. thrADraw Threshold drainage area value used display network. exactDraw TRUE, real shape OCNs plotted. flow crosses boundary,  pixel contiguous outlet flipped. effective OCN$PeriodicBoundaries = TRUE drawContours TRUE, plot catchment(s) contours. colPalRiver Color palette used plot river network(s). Default rearranged version theme \"Dark 3\" (see hcl.pals). colPalRiver accepts functions creating color palettes vectors colors (first OCN$nOutlet elements used). single color value provided OCN$nOutlet > 1, river networks drawn color. colPalCont Color palette used plot catchment contour(s). Details colPalRiver. Additionally, colPalCont = 0, palette specified colPalRiver copied. drawOutlets equal 1, black squares drawn outlets' locations behind river; 2 plotted top river. pch Shape outlet points (drawOutlets = TRUE). See points legend. colPalOut Color palette used plot outlet points (drawOutlets = TRUE). Details colPalRiver. Additionally, colPalOut = 0, palette specified colPalRiver copied. min_lwd, max_lwd Minimum maximum values line width used display OCN (actual line width proportional square root drainage area).","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/draw_contour_OCN.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Draw Optimal Channel Network with catchment contours — draw_contour_OCN","text":"output returned.","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/draw_contour_OCN.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Draw Optimal Channel Network with catchment contours — draw_contour_OCN","text":"large networks (.e. OCN$FD$nNodes <= 40000, corresponding 200x200 lattice),  pixels whose drainage area OCN$FD$lower thrADraw drawn light grey stroke. OCN$FD$nNodes > 40000, order speed execution function, network constituted  pixels OCN$FD$> thrADraw drawn.","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/draw_contour_OCN.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Draw Optimal Channel Network with catchment contours — draw_contour_OCN","text":"","code":"# 1) draw contour of a 20x20 single-outlet OCN # (for single-outlet OCNs without periodic boundaries, the output # of draw_contour_OCN is very similar to that of draw_simple_OCN) draw_contour_OCN(landscape_OCN(OCN_20), thrADraw = 4)   if (FALSE) { # 2a) plot real shape of multiple-outlet OCN created with periodic boundaries # add outlets on top of the rivers OCN <- landscape_OCN(OCN_300_4out_PB_hot, displayUpdates = 2) # it takes around one minute draw_contour_OCN(OCN, drawOutlets = 2)  # 2b) same as before, but use same color palette for rivers and contours draw_contour_OCN(OCN, colPalCont = 0)  # 2c) draw contours of catchments obtained from an OCN with nOutlet = \"All\" OCN <- landscape_OCN(OCN_400_Allout, displayUpdates = 2) # it takes some minutes draw_contour_OCN(OCN)  # 2d) same as above, but do not plot contours, and plot outlets  # with same color palette as rivers draw_contour_OCN(OCN, drawContours = FALSE, drawOutlets = TRUE,     colPalOut = 0)  }"},{"path":"https://lucarraro.github.io/OCNet/reference/draw_elev2D_OCN.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot 2D map of elevation generated by an OCN — draw_elev2D_OCN","title":"Plot 2D map of elevation generated by an OCN — draw_elev2D_OCN","text":"Function plots 2D elevation map generated OCN.","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/draw_elev2D_OCN.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot 2D map of elevation generated by an OCN — draw_elev2D_OCN","text":"","code":"draw_elev2D_OCN(OCN, colPalette = terrain.colors(1000, alpha = 1), addLegend = TRUE, drawRiver = FALSE, thrADraw = 0.002*OCN$FD$nNodes*OCN$cellsize^2, riverColor = \"#00BFFF\", min_lwd = 0.5, max_lwd = 5, args_imagePlot = list())"},{"path":"https://lucarraro.github.io/OCNet/reference/draw_elev2D_OCN.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot 2D map of elevation generated by an OCN — draw_elev2D_OCN","text":"OCN List produced landscape_OCN. colPalette Color palette used plot. addLegend Logical. TRUE, image.plot used display legend; result, elements (e.g. node coordinates) subsequently plotted top 2D elevation map might wrongly positioned. drawRiver Logical. TRUE, draw OCN top elevation map. thrADraw Threshold drainage area value used display network. riverColor Color used display OCN (effective drawRiver = TRUE). min_lwd, max_lwd Minimum maximum values line width used display OCN (actual line width proportional square root drainage area). args_imagePlot List arguments passed imagePlot (image addLegend = FALSE). example, argument smallplot can used specify plot coordinates legend.","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/draw_elev2D_OCN.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot 2D map of elevation generated by an OCN — draw_elev2D_OCN","text":"output returned.","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/draw_elev2D_OCN.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot 2D map of elevation generated by an OCN — draw_elev2D_OCN","text":"","code":"# 1) draw 2D map of a 20x20 OCN with default settings draw_elev2D_OCN(landscape_OCN(OCN_20))"},{"path":"https://lucarraro.github.io/OCNet/reference/draw_elev3D_OCN.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot 3D map of elevation generated by an OCN — draw_elev3D_OCN","title":"Plot 3D map of elevation generated by an OCN — draw_elev3D_OCN","text":"Function plots 3D elevation map generated OCN.","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/draw_elev3D_OCN.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot 3D map of elevation generated by an OCN — draw_elev3D_OCN","text":"","code":"draw_elev3D_OCN(OCN, coarseGrain = c(1,1), colPalette = terrain.colors(1000, alpha = 1),   addColorbar = TRUE, drawRiver = TRUE, thrADraw = 0.002 *   OCN$FD$nNodes * OCN$cellsize^2, riverColor = \"#00CCFF\",   theta = -20, phi = 30, expand = 0.05, shade = 0.5, min_lwd = 0.5, max_lwd = 5,    args_imagePlot = list())"},{"path":"https://lucarraro.github.io/OCNet/reference/draw_elev3D_OCN.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot 3D map of elevation generated by an OCN — draw_elev3D_OCN","text":"OCN List produced landscape_OCN. coarseGrain 2x1 vector (effective chooseCM = FALSE). aesthetic purposes, elevation map can coarse-grained OCN$dimX/coarseGrain[1]--OCN$dimX/coarseGrain[2]  domain, cell's elevation average elevations corresponding coarseGrain[1]--coarseGrain[2] cells original elevation field.  coarseGrain[1] coarseGrain[2] must divisors OCN$dimX OCN$dimY, respectively. coarseGrain = c(2,2) often sufficient achieve good graphical results large  (.e. least 100x100 nodes) OCNs. colPalette Color palette used plot. addColorbar TRUE, add colorbar plot. drawRiver TRUE, draw OCN top elevation field. thrADraw Threshold drainage area value used display network. riverColor Color used plot river. theta, phi, expand, shade Additional parameters passed perspective plotting  function persp. theta expresses azimuthal direction; phi gives  colatitude; expand expansion factor Z coordinates; shade controls shade surface facet. min_lwd, max_lwd Minimum maximum values line width used display OCN (actual line width proportional square root drainage area). args_imagePlot effective addColorbar = TRUE. List arguments passed imagePlot drawing continuous legend. example, argument smallplot can used specify plot coordinates legend.","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/draw_elev3D_OCN.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot 3D map of elevation generated by an OCN — draw_elev3D_OCN","text":"output returned.","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/draw_elev3D_OCN.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot 3D map of elevation generated by an OCN — draw_elev3D_OCN","text":"","code":"# draw 3D representation of a 20x20 OCN with default options draw_elev3D_OCN(landscape_OCN(OCN_20))   if (FALSE) { # 1a) draw the 3D representation of the OCN (without displaying the river   # and the colorbar) and enhance the aspect ratio of Z coordinates  # with respect to the default value (the final result will be ugly): OCN <- landscape_OCN(OCN_400_Allout, displayUpdates = 2) # this takes some minutes   draw_elev3D_OCN(OCN, expand = 0.2, addColorbar = FALSE, drawRiver = FALSE)  # 1b) same as above, but operate coarse graining  and modify shade for better aesthetics:  draw_elev3D_OCN(OCN, coarseGrain = c(5,5), expand = 0.2,      shade = 0.25, addColorbar = FALSE, drawRiver = FALSE) }"},{"path":"https://lucarraro.github.io/OCNet/reference/draw_elev3Drgl_OCN.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot 3D map of elevation generated by an OCN via rgl rendering — draw_elev3Drgl_OCN","title":"Plot 3D map of elevation generated by an OCN via rgl rendering — draw_elev3Drgl_OCN","text":"Function plots 3D elevation map generated OCN.","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/draw_elev3Drgl_OCN.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot 3D map of elevation generated by an OCN via rgl rendering — draw_elev3Drgl_OCN","text":"","code":"draw_elev3Drgl_OCN(OCN, coarseGrain = c(1, 1), chooseCM = FALSE,   addColorbar = FALSE, drawRiver = FALSE, thrADraw = 0.002 *   OCN$FD$nNodes* OCN$cellsize^2, riverColor = \"#00CCFF\",    min_lwd = 1, max_lwd = 8, ...)"},{"path":"https://lucarraro.github.io/OCNet/reference/draw_elev3Drgl_OCN.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot 3D map of elevation generated by an OCN via rgl rendering — draw_elev3Drgl_OCN","text":"OCN List produced landscape_OCN. coarseGrain 2x1 vector (effective chooseCM = FALSE). aesthetic purposes, elevation map can coarse-grained OCN$dimX/coarseGrain[1]--OCN$dimX/coarseGrain[2]  domain, cell's elevation average elevations corresponding coarseGrain[1]--coarseGrain[2] cells original elevation field.  coarseGrain[1] coarseGrain[2] must divisors OCN$dimX OCN$dimY, respectively. coarseGrain = c(2,2) often sufficient achieve good graphical results large  (.e. least 100x100 nodes) OCNs. chooseCM Index catchment display (effective OCN$nOutlet > 1). can logical, scalar within 1:length(OCN$nOutlet).  TRUE, catchment largest area displayed. Note , size chosen catchment small (e.g. OCN$CM$[chooseCM] < 5*OCN$cellsize^2), error might occur due failure triangulation. addColorbar TRUE, add colorbar plot. drawRiver TRUE, draw OCN top elevation field. thrADraw Threshold drainage area value used display network. riverColor Color used plot river. min_lwd, max_lwd Minimum maximum values line width used display OCN (actual line width proportional square root drainage area). ... parameters passed function persp3d. default value aspect c(OCN$dimX/sqrt(OCN$dimX*OCN$dimY, OCN$dimY/sqrt(OCN$dimX*OCN$dimY, 1)).","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/draw_elev3Drgl_OCN.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot 3D map of elevation generated by an OCN via rgl rendering — draw_elev3Drgl_OCN","text":"output returned.","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/draw_elev3Drgl_OCN.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot 3D map of elevation generated by an OCN via rgl rendering — draw_elev3Drgl_OCN","text":"function makes use rgl rendering system. export figure raster format, use rgl.snapshot.  export vectorial format, use rgl.postscript (note might produce rendering issues, see rgl details). function attempt drawing contour plotted entity (.e. lattice catchment, depending chooseCM) null elevation, drawing polygons connecting contour lattice/catchment contour real elevation. chooseCM != FALSE, might result errors owing failure polygon3d triangulating polygons.","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/draw_elev3Drgl_OCN.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot 3D map of elevation generated by an OCN via rgl rendering — draw_elev3Drgl_OCN","text":"","code":"if (FALSE) { draw_elev3Drgl_OCN(landscape_OCN(OCN_20)) }  if (FALSE) { # 1a) draw the 3D representation of a single catchment within an OCN  # generated with nOutlet = \"All\" and add draw the river on top of it OCN <- landscape_OCN(OCN_400_Allout, displayUpdates = 2) # this takes some minutes draw_elev3Drgl_OCN(OCN, chooseCM = 983, drawRiver = TRUE)  # 1b) draw the 3D representation of the largest catchment within the OCN  # (here polygon3d may fail at plotting the polygon at zero elevation)    draw_elev3Drgl_OCN(OCN, chooseCM = TRUE)   # 1c) draw the 3D representation of the whole OCN # and enhance the aspect ratio of Z coordinates  # with respect to the default value (the final result will be ugly):   draw_elev3Drgl_OCN(OCN, aspect = c(1, 1, 0.2))  # 1d) same as above, but operate coarse graining for better aesthetics:  draw_elev3Drgl_OCN(OCN, coarseGrain = c(5,5), aspect = c(1, 1, 0.2))  # 2) draw the 3D representation of a single catchment of an OCN generated # with periodicBoundaries = TRUE # (note that the real shape of the catchment is drawn) OCN <- landscape_OCN(OCN_300_4out_PB, displayUpdates = 2) # this takes some minutes draw_elev3Drgl_OCN(OCN, chooseCM = TRUE)  }"},{"path":"https://lucarraro.github.io/OCNet/reference/draw_simple_OCN.html","id":null,"dir":"Reference","previous_headings":"","what":"Draw an Optimal Channel Network — draw_simple_OCN","title":"Draw an Optimal Channel Network — draw_simple_OCN","text":"Function plots non-aggregated OCN calculated create_OCN.","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/draw_simple_OCN.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Draw an Optimal Channel Network — draw_simple_OCN","text":"","code":"draw_simple_OCN(OCN, thrADraw = 0.002 * OCN$FD$nNodes *   OCN$cellsize^2, riverColor = \"#0066FF\", easyDraw = NULL,    min_lwd = 0.5,  max_lwd = 5)"},{"path":"https://lucarraro.github.io/OCNet/reference/draw_simple_OCN.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Draw an Optimal Channel Network — draw_simple_OCN","text":"OCN List produced create_OCN. thrADraw Threshold drainage area value used display network. riverColor Color used plot river. easyDraw Logical. TRUE, whole network displayed, pixels drainage area lower thrADraw displayed light gray. FALSE, pixels drainage area greater equal thrADraw displayed. Default FALSE OCN$nNodes <= 40000, TRUE otherwise. Note setting easyDraw = FALSE large networks might slow process considerably. min_lwd, max_lwd Minimum maximum values line width used display OCN (actual line width proportional square root drainage area).","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/draw_simple_OCN.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Draw an Optimal Channel Network — draw_simple_OCN","text":"output returned.","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/draw_simple_OCN.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Draw an Optimal Channel Network — draw_simple_OCN","text":"","code":"# 1a) draw OCN with default settings draw_simple_OCN(OCN_250_T)  # 1b) same as above, but with decreased thrADraw draw_simple_OCN(OCN_250_T, thrADraw = 0.001 * OCN_250_T$dimX * OCN_250_T$dimY)  # \\donttest{ # 1c) same as the first example, but include the portion of network   # with drainage area lower than thrADraw  draw_simple_OCN(OCN_250_T, easyDraw = FALSE) # this will take some seconds  # }"},{"path":"https://lucarraro.github.io/OCNet/reference/draw_subcatchments_OCN.html","id":null,"dir":"Reference","previous_headings":"","what":"Draw subcatchment map from an Optimal Channel Network — draw_subcatchments_OCN","title":"Draw subcatchment map from an Optimal Channel Network — draw_subcatchments_OCN","text":"Function draws map subcatchments generated aggregation process OCN. theme NULL, colormap neighbouring subcatchments distinguished colors. theme specified, colors reflect values theme across subcatchments, analogy draw_thematic_OCN.","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/draw_subcatchments_OCN.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Draw subcatchment map from an Optimal Channel Network — draw_subcatchments_OCN","text":"","code":"draw_subcatchments_OCN(OCN, theme = NULL, drawRiver = TRUE,  colPalette = NULL, colLevels = NULL, riverColor = NULL, addLegend = NULL,   min_lwd = 0.5, max_lwd = 5, add = FALSE, args_imagePlot = list(), ...)"},{"path":"https://lucarraro.github.io/OCNet/reference/draw_subcatchments_OCN.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Draw subcatchment map from an Optimal Channel Network — draw_subcatchments_OCN","text":"OCN List produced aggregate_OCN. theme Vector (length OCN$SC$Nnodes expressing spatial field interest. drawRiver Logical. TRUE, draw OCN top subcatchment map. colPalette Color palette used. colPalette accepts functions creating color palettes vectors colors. latter case, length(colPalette) must greater number color levels. theme = NULL, default c(\"#009900\", \"#FFFF00\",  \"#FF9900\", \"#FF0000\", \"#FF00FF\",  \"#9900CC\", \"#555555\", \"#BBBBBB\"). first n colors used, n number different colors needed (calculated via greedy coloring algorithm). colPalette accepts functions creating color palettes vectors colors (see examples); latter case, length vector lower n (n predicted priori, generally 6 colors suffice). theme != NULL, default colorRampPalette(c(\"yellow\",\"red\",\"black\")). colLevels Number colors palette (effective theme null). colLevels must vector form c(minval, maxval) c(minval, maxval, N_levels). vector breakpoints used attribute theme values given color defined seq(minval, maxval, N_levels). Default minval = min(theme[!(.nan(theme))]), maxval = max(theme[!(.nan(theme))]), N_levels = 1000. riverColor Color used display OCN (effective drawRiver = TRUE). addLegend Logical. State legend displayed (active theme null. min_lwd, max_lwd Minimum maximum values line width used display OCN (actual line width proportional square root drainage area). add Logical. TRUE, add already existing plot. Taken FALSE (warning different value supplied) graphics device open. args_imagePlot effective addLegend = TRUE. List arguments passed imagePlot drawing continuous legend. example, argument smallplot can used specify plot coordinates legend. ... arguments passed image. Default plot options draw_thematic_OCN.","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/draw_subcatchments_OCN.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Draw subcatchment map from an Optimal Channel Network — draw_subcatchments_OCN","text":"output returned.","code":""},{"path":[]},{"path":"https://lucarraro.github.io/OCNet/reference/draw_subcatchments_OCN.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Draw subcatchment map from an Optimal Channel Network — draw_subcatchments_OCN","text":"","code":"# 1a) aggregate a 20x20 OCN , use thrA = 5 pixels # and draw subcatchments with default color palette OCN <- aggregate_OCN(landscape_OCN(OCN_20), thrA = 5) draw_subcatchments_OCN(OCN, drawRiver = TRUE)   # 1b) same as above, but define color palette with a function draw_subcatchments_OCN(OCN, drawRiver = TRUE, colPalette = rainbow)   # 1c) same as above, but define color palette with a vector of colors draw_subcatchments_OCN(OCN, drawRiver = TRUE, colPalette = hcl.colors(6, \"Dark 3\"))   # 2) Display theme at subcatchment level draw_subcatchments_OCN(OCN, theme = OCN$AG$A)"},{"path":"https://lucarraro.github.io/OCNet/reference/draw_thematic_OCN.html","id":null,"dir":"Reference","previous_headings":"","what":"Draw thematic map on an Optimal Channel Network — draw_thematic_OCN","title":"Draw thematic map on an Optimal Channel Network — draw_thematic_OCN","text":"Function draws OCNs color RN AG nodes depending arbitrary theme.","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/draw_thematic_OCN.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Draw thematic map on an Optimal Channel Network — draw_thematic_OCN","text":"","code":"draw_thematic_OCN(OCN,theme=NA*numeric(OCN$AG$nNodes),   chooseAggregation = NULL,   discreteLevels = FALSE,    colLevels = NULL, cutoff = FALSE,   colPalette = colorRampPalette(c(\"yellow\",\"red\",\"black\")),   exactDraw = FALSE, chooseCM = FALSE, drawNodes = FALSE,     nodeType = \"upstream\",  nanColor = \"#00BFFF\",   riverColor = \"#00BFFF\", backgroundColor = \"#999999\",    addLegend = TRUE, min_lwd = 0.5, max_lwd = 5,    add = FALSE, args_imagePlot = list(), args_legend = list(),    ...)"},{"path":"https://lucarraro.github.io/OCNet/reference/draw_thematic_OCN.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Draw thematic map on an Optimal Channel Network — draw_thematic_OCN","text":"OCN List produced aggregate_OCN. order arguments OCN theme can swapped freely. theme Vector (length OCN$AG$Nnodes OCN$RN$Nnodes) expressing spatial field interest.  vector can contain NA NaN values identify RN AG nodes theme defined. order arguments OCN theme can swapped freely. chooseAggregation effective OCN$RN$nNodes == OCN$AG$nNodes. case, must equal either \"RN\" \"AG\"; result, theme interpreted spatial field corresponding aggregation level. discreteLevels Logical. FALSE, continuous color scheme used. TRUE, discrete color levels applied. See also colLevels examples. colLevels Number colors palette. discreteLevels == FALSE, colLevels must vector form c(minval, maxval) c(minval, maxval, N_levels). vector breakpoints used attribute theme values given color defined seq(minval, maxval, N_levels). Default minval = min(theme[!(.nan(theme))]), maxval = max(theme[!(.nan(theme))]), N_levels = 1000. discreteLevels == TRUE .null(colLevels) == TRUE, unique value theme attributed different color. discreteLevels == TRUE colLevels vector, colLevels used vector breakpoints. case, number discrete colors equal length(colLevels) - 1. cutoff Logical. FALSE, nodes whose theme value beyond range established vector breakpoints attributed color corresponding lowest (highest) value color scheme. TRUE, nodes attributed color NaNcolor. colPalette Color palette used display theme values. colPalette accepts functions creating color palettes vectors colors. latter case, length(colPalette) must greater number color levels. See examples hcl.colors. chooseCM Index catchment display (effective OCN$nOutlet > 1). can logical numeric vector. FALSE, catchments displayed. TRUE, catchment largest area displayed. chooseCM subset vector 1:length(OCN$nOutlet), catchment(s) identified indices chooseCM displayed. exactDraw Logical. TRUE, real shape OCNs plotted. flow crosses boundary, pixel contiguous outlet flipped. drawNodes Logical. FALSE, theme directly displayed river network. case, edge departing given node displayed color attributed node. TRUE, theme displayed via markers locations nodes RN AG level (depending length theme). case, nanColor can used define color river network. nodeType effective drawNodes == TRUE length(theme) == OCN$RN$nNodes. Can assume values \"upstream\" \"downstream\". \"upstream\", nodes drawn upstream ends corresponding edges (.e. coordinates defined OCN$AG$X, OCN$AG$Y). \"downstream\", nodes drawn downstream ends corresponding edges (.e. coordinates defined OCN$AG$XReach, OCN$AG$YReach). nanColor Color attributed RN AG nodes whose theme value NA NaN. riverColor effective drawNodes == TRUE. Color used display OCN nodes. backgroundColor Color used background figure. can either single value, vector number components  equal length(chooseCM). length(backgroundColor) == length(chooseCM), color used identify different catchment selected chooseCM (corresponding respective outlet). instead length(chooseCM) > 1 length(backgroundColor) == 1, catchments colored  backgroundColor. addLegend Logical. TRUE, add legend plot. also discreteLevels = FALSE, image.plot used display legend, appears colorbar; result, elements (e.g. node coordinates) subsequently plotted top 2D elevation map might wrongly positioned. min_lwd, max_lwd Minimum maximum values line width used display OCN (actual line width proportional square root drainage area). add Logical. TRUE, add already existing plot. Taken FALSE (warning different value supplied) graphics device open. args_imagePlot effective addLegend = TRUE discreteLevels = FALSE. List arguments passed imagePlot drawing continuous legend. example, argument smallplot can used specify plot coordinates legend. args_legend effective addLegend = TRUE discreteLevels = TRUE. List arguments passed legend drawing discrete legend. ... arguments passed plot.","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/draw_thematic_OCN.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Draw thematic map on an Optimal Channel Network — draw_thematic_OCN","text":"output returned.","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/draw_thematic_OCN.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Draw thematic map on an Optimal Channel Network — draw_thematic_OCN","text":"function can used show certain spatial field varies along river network. Default plot options. default, set asp = 1, xlab = \"\", ylab = \"\". least one xlim ylim specified user, default axes TRUE, FALSE . Specifying xlim ylim helps zoom portion river network; however, due default asp = 1, displayed region might larger expected ranges xlim ylim different. avoid , set asp = NA (cost producing deformed river network).","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/draw_thematic_OCN.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Draw thematic map on an Optimal Channel Network — draw_thematic_OCN","text":"","code":"# 1a) Six different ways to display contributing area at the AG level OCN <- aggregate_OCN(landscape_OCN(OCN_20), thrA = 4) old.par <- par(no.readonly = TRUE) par(mfrow=c(2,3), oma = c(0, 0, 3, 0)) draw_thematic_OCN(OCN$AG$A, OCN, colPalette = hcl.colors)  title(\"Continuous levels \\n Colors on edges\") draw_thematic_OCN(OCN$AG$A, OCN, discreteLevels = TRUE,     colPalette = hcl.colors)  title(\"Discrete, unique levels \\n Colors on edges\") draw_thematic_OCN(OCN$AG$A, OCN, discreteLevels = TRUE,      colLevels = c(1, 10, 50, 100, 500),      colPalette = hcl.colors)  title(\"Discrete, user-defined levels \\n Colors on edges\") draw_thematic_OCN(OCN$AG$A, OCN, drawNodes = TRUE,      colPalette = hcl.colors) title(\"Continuous levels \\n Colors on edges\") draw_thematic_OCN(OCN$AG$A, OCN,  discreteLevels = TRUE,      drawNodes = TRUE, colPalette = hcl.colors) title(\"Discrete, unique levels \\n Colors on nodes\") draw_thematic_OCN(OCN$AG$A, OCN, discreteLevels = TRUE,      drawNodes = TRUE, colLevels = c(1, 10, 50, 100, 500),      colPalette = hcl.colors) title(\"Discrete, user-defined levels \\n Colors on nodes\") mtext(\"Six different ways to display contributing area [no. pixels]\", outer = TRUE, cex = 1.5)  par(old.par)  # 1b) Same as above, but use different colLevels, cutoff combinations # with DiscreteLevels = FALSE old.par <- par(no.readonly = TRUE) par(mfrow=c(1,2)) draw_thematic_OCN(OCN$AG$A, OCN, drawNodes = TRUE,      colLevels = c(0, 200, 1000), colPalette = hcl.colors) title(\"All nodes with A > 200 pixels \\n are displayed in yellow\") draw_thematic_OCN(OCN$AG$A, OCN, drawNodes = TRUE,      nanColor = \"#00000000\", colLevels = c(0, 200, 1000),     cutoff = TRUE, colPalette = hcl.colors) title(\"All nodes with A > 200 pixels \\n are treated as NaN\")      par(old.par)  if (FALSE) { # 2) Display distance to outlet (at the RN level) along the main stem # of an OCN OCN <- aggregate_OCN(landscape_OCN(OCN_250_T)) # this takes some seconds OCN <- paths_OCN(OCN, includePaths = TRUE) # this takes some seconds  distanceToOutlet <- OCN$RN$downstreamPathLength[,OCN$RN$outlet] farthestNode <- which(distanceToOutlet == max(distanceToOutlet)) mainStem <- OCN$RN$downstreamPath[[farthestNode]][[OCN$RN$outlet]] theme <- rep(NaN, OCN$RN$nNodes) theme[mainStem] <- distanceToOutlet[mainStem]  draw_thematic_OCN(theme, OCN) title(\"Distance to outlet along the main stem [pixel units]\") }  # 3) Show an OCN without a theme OCN <- aggregate_OCN(landscape_OCN(OCN_20), thrA = 4) draw_thematic_OCN(OCN)  draw_thematic_OCN(OCN, xlim=c(3,8), ylim=c(0,5)) # zoom closer at the outlet   # 4) Adjust legend location draw_thematic_OCN(OCN, OCN$AG$A,    args_imagePlot = list(smallplot = c(0.1, 0.11, 0.1, 0.3)))  draw_thematic_OCN(OCN, OCN$AG$streamOrder,    discreteLevels = TRUE, args_legend = list(x = -2, y = 1))   # 5) add thematic OCN on top of map draw_elev2D_OCN(OCN) draw_thematic_OCN(OCN, OCN$AG$slope, backgroundColor = NULL,  add = TRUE, colPalette = hcl.colors(1000, \"Grays\", rev = TRUE), args_imagePlot = list(smallplot=c(0.05,0.07,0.1,0.9)))"},{"path":"https://lucarraro.github.io/OCNet/reference/find_area_threshold_OCN.html","id":null,"dir":"Reference","previous_headings":"","what":"Find relationship between number of nodes and threshold area in an OCN — find_area_threshold_OCN","title":"Find relationship between number of nodes and threshold area in an OCN — find_area_threshold_OCN","text":"Function calculates relationship threshold area number nodes RN AG level given OCN.  can used prior application aggregate_OCN order derive drainage area threshold  corresponds desired number nodes aggregated network. intended use single outlet OCNs, although use multiple outlet OCNs allowed (provided max(thrValues) <= min(OCN$CM$)).","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/find_area_threshold_OCN.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find relationship between number of nodes and threshold area in an OCN — find_area_threshold_OCN","text":"","code":"find_area_threshold_OCN(OCN, thrValues = seq(OCN$cellsize^2,   min(OCN$CM$A), OCN$cellsize^2), maxReachLength = Inf,   streamOrderType = \"Strahler\", displayUpdates = 0)"},{"path":"https://lucarraro.github.io/OCNet/reference/find_area_threshold_OCN.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find relationship between number of nodes and threshold area in an OCN — find_area_threshold_OCN","text":"OCN List produced landscape_OCN thrValues Vector values threshold drainage area (squared planar units) respective number nodes RN AG levels computed. Note must max(thrValues) <= min(OCN$CM$), otherwise catchment(s) area lower max(thrValues) degenerate network zero nodes RN/AG level. maxReachLength Maximum reach length allowed (planar units). path length channel head downstream confluence  higher maxReachLength, reach starting channel head length maxReachLength, next downstream  pixel considered new channel head, new reach departs. streamOrderType \"Strahler\", Strahler stream order computed; \"Shreve\", Shreve stream order computed. displayUpdates 1, progress updates printed console function running. 0, updates printed.","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/find_area_threshold_OCN.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find relationship between number of nodes and threshold area in an OCN — find_area_threshold_OCN","text":"list whose objects listed . thrValues Copy input vector name. nNodesRN Vector (length thrValues) number nodes RN level resulting aggregation process  threshold area values specified thrValues. nNodesAG Vector (length thrValues) number nodes AG level resulting aggregation process  threshold area values specified thrValues. drainageDensity Vector (length thrValues) values drainage density river network  resulting aggregation process threshold area values specified thrValues. Drainage density calculated  total length river network divided area lattice. expressed planar units^(-1). streamOrder Vector (length thrValues) values maximum stream order attained river network,  resulting aggregation process threshold area values specified thrValues.","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/find_area_threshold_OCN.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find relationship between number of nodes and threshold area in an OCN — find_area_threshold_OCN","text":"","code":"# 1) derive relationship between threshold area and number of nodes OCN <- landscape_OCN(OCN_20) thr <- find_area_threshold_OCN(OCN) # log-log plot of number of nodes at the AG level versus  # relative threshold area (as fraction of total drainage area)  old.par <- par(no.readonly = TRUE) par(mai = c(1,1,1,1))   plot(thr$thrValues[thr$nNodesAG > 0]/OCN$CM$A,     thr$nNodesAG[thr$nNodesAG > 0], log = \"xy\",     xlab = \"Relative area threshold\", ylab = \"Number of AG nodes\")  par(old.par)"},{"path":"https://lucarraro.github.io/OCNet/reference/flowDir.html","id":null,"dir":"Reference","previous_headings":"","what":"Example of initial flow direction matrix to be used as input in create_general_contour_OCN. — flowDir","title":"Example of initial flow direction matrix to be used as input in create_general_contour_OCN. — flowDir","text":"arbitrary initial flow direction matrix.","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/flowDir.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example of initial flow direction matrix to be used as input in create_general_contour_OCN. — flowDir","text":"","code":"data(flowDir)"},{"path":"https://lucarraro.github.io/OCNet/reference/flowDir.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example of initial flow direction matrix to be used as input in create_general_contour_OCN. — flowDir","text":"matrix. See create_general_contour_OCN documentation details.","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/landscape_OCN.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate 3D landscape from an Optimal Channel Network — landscape_OCN","title":"Generate 3D landscape from an Optimal Channel Network — landscape_OCN","text":"Function calculates elevation field generated OCN partition domain different catchments.","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/landscape_OCN.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate 3D landscape from an Optimal Channel Network — landscape_OCN","text":"","code":"landscape_OCN(OCN, slope0 = 1, zMin = 0, optimizeDZ = FALSE,   optimMethod = \"BFGS\", optimControl = list(maxit = 100 *   length(OCN$FD$outlet), trace = 1), displayUpdates = 0)"},{"path":"https://lucarraro.github.io/OCNet/reference/landscape_OCN.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate 3D landscape from an Optimal Channel Network — landscape_OCN","text":"OCN List produced create_OCN. slope0 slope outlet pixel (elevation units/planar units). zMin Elevation lowest pixel (elevation units). optimizeDZ TRUE, multiple catchments, minimize differences elevation catchment borders  lifting catchments, respecting zMin. FALSE, outlet pixels elevation equal zMin.  option effective OCNs generated via create_general_contour_OCN. optimMethod Optimization method used function optim (used optimizeDZ = TRUE). optimControl List control parameters used function optim (used optimizeDZ = TRUE). displayUpdates State updates printed console landscape_OCN runs. 0 update given. 1 Concise updates given. 2 extensive updates given (might slow total function runtime). Note display updates optimization elevations (optimizeDZ = TRUE) controlled parameter optimControl$trace.","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/landscape_OCN.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate 3D landscape from an Optimal Channel Network — landscape_OCN","text":"list contains objects contained OCN, addition objects listed .  new sublist CM, containing variables catchment aggregation levels, created. FD$slope Vector (length OCN$FD$nNodes) slope values (elevation units/planar units)  FD pixel, derived slope/area relationship. FD$leng Vector (length OCN$FD$nNodes) pixel lengths. OCN$FD$leng[] = OCN$FD$cellsize  flow direction horizontal vertical; OCN$FD$leng[] = OCN$FD$cellsize*sqrt(2) flow direction diagonal. FD$toCM Vector (length OCN$FD$nNodes) catchment index values FD pixel.  Example: OCN$FD$toCM[] = j pixel drains outlet whose location defined  outletSide[j], outletPos[j]. FD$XDraw periodicBoundaries = TRUE, vector (length OCN$FD$nNodes) real X coordinate FD pixels.  periodicBoundaries = FALSE, equal OCN$FD$X. FD$YDraw periodicBoundaries = TRUE, vector (length OCN$FD$nNodes) real Y coordinate FD pixels.  periodicBoundaries = FALSE, equal OCN$FD$Y. FD$Z Vector (length OCN$FD$nNodes) elevation values FD pixel. Values calculated consecutive implementation  slope/area relationship along upstream paths. CM$Vector (length OCN$nOutlet) values drainage area (square planar units) catchments  identified corresponding OCN$FD$outlet. CM$W Adjacency matrix (OCN$nOutlet OCN$nOutlet) catchment level. Two catchments connected  share border. Note flow connection. Unlike adjacency matrices levels FD, RN, AG, matrix symmetric.  spam object. CM$XContour (CM$Y_contour) List number objects equal OCN$FD$nOutlet. object list  X (Y) coordinates contour catchment use plots exactDraw = FALSE (see functions draw_contour_OCN,  draw_thematic_OCN). catchment constituted regions connected diagonal flow direction,  CM$XContour[[]] (CM$Y_contour[[]]) contains many objects number regions catchment split. CM$XContourDraw (CM$YContourDraw) List number objects equal OCN$FD$nOutlet. object list  X (Y) coordinates contour catchment use plots exactDraw = TRUE (see functions draw_contour_OCN,  draw_thematic_OCN). catchment constituted regions connected diagonal flow direction,  CM$XContourDraw[[]] (CM$YContourDraw[[]]) contains many objects number regions catchment split. OptList List output parameters produced optimization function optim (present optimizeDZ = TRUE). Finally, slope0 zMin passed list included input.","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/landscape_OCN.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate 3D landscape from an Optimal Channel Network — landscape_OCN","text":"function features algorithm (can activated via optional input optimizeDZ) , given network  configuration slope0 value, finds elevation OCN$nOutlet - 1 outlets relative elevation first  outlet vectors outletSide, outletPos sum absolute differences elevation neighboring pixels belonging different catchments minimized. objective function minimized means function optim.  absolute elevation outlet pixels (, consequently, whole lattice) finally attributed imposing  OCN$FD$Z >= zMin. Note , due high dimensionality problem, convergence  optimization algorithm guaranteed large OCN$nOutlet (say, OCN$nOutlet > 10).","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/landscape_OCN.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate 3D landscape from an Optimal Channel Network — landscape_OCN","text":"","code":"# 1) draw 2D elevation map of a 20x20 OCN with default options OCN2 <- landscape_OCN(OCN_20)  if (FALSE) { # 2) generate a 100x50 OCN; assume that the pixel resolution is 200 m # (the total catchment area is 20 km2) set.seed(1) OCN <- create_OCN(100, 50, cellsize = 200,      displayUpdates = 0) # this takes about 40 s # use landscape_OCN to derive the 3D landscape subsumed by the OCN # by assuming that the elevation and slope at the outlet are 200 m  # and 0.0075, respectively OCN <- landscape_OCN(OCN, zMin = 200, slope0 = 0.0075) # draw 2D and 3D representations of the landscape draw_elev2D_OCN(OCN) draw_elev3D_OCN(OCN) draw_elev3Drgl_OCN(OCN) }  if (FALSE) { # 3) generate a 100x50 OCN with 4 outlets set.seed(1) OCN <- create_OCN(100, 50, cellsize = 200,      nOutlet = 4, displayUpdates = 0) # this takes about 40 s # use landscape_OCN and optimize elevation of outlets   OCN <- landscape_OCN(OCN, slope0 = 0.0075,      optimizeDZ = TRUE) # display elevation of outlets and 2D elevation map OCN$FD$Z[OCN$FD$outlet]   draw_elev2D_OCN(OCN)   }"},{"path":"https://lucarraro.github.io/OCNet/reference/paths_OCN.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate paths between nodes in an Optimal Channel Network — paths_OCN","title":"Calculate paths between nodes in an Optimal Channel Network — paths_OCN","text":"Function determines upstream downstream paths path lengths nodes network aggregated level.","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/paths_OCN.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate paths between nodes in an Optimal Channel Network — paths_OCN","text":"","code":"paths_OCN(OCN, level = c(\"RN\",\"AG\"), includePaths = FALSE,  includeDownstreamNode = FALSE, includeUnconnectedPaths = FALSE, displayUpdates = FALSE)"},{"path":"https://lucarraro.github.io/OCNet/reference/paths_OCN.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate paths between nodes in an Optimal Channel Network — paths_OCN","text":"OCN List produced aggregate_OCN. level Character vector. level paths calculated? Possible values \"RN\", \"AG\", . includePaths Logical. TRUE, RN$downstreamPath AG$downstreamPath included output list. Note might slow function execution considerably, create RAM issues large OCNs. includeDownstreamNode Logical. TRUE, path lengths include length edge departing last downstream node path. includeUnconnectedPaths Logical. TRUE, calculate path lengths unconnected nodes (RN$downstreamLengthUnconnected AG$downstreamLengthUnconnected). Note might slow function execution considerably, create RAM issues large OCNs. displayUpdates Logical. State updates printed console paths_OCN runs.","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/paths_OCN.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate paths between nodes in an Optimal Channel Network — paths_OCN","text":"list contains objects contained OCN, addition objects listed . RN$downstreamPath List (length OCN$RN$nNodes) whose object list (length OCN$RN$nNodes).  nodes j connected downstream path, RN$downstreamPath[[]][[j]] vector  containing indices nodes constituting path (j included). j connected  downstream path, RN$downstreamPath[[]][[j]] = NULL. present includePaths = TRUE. RN$downstreamPathLength Sparse matrix (OCN$RN$nNodes OCN$RN$nNodes) containing length paths nodes  connected downstream path; j connected downstream path, RN$downstreamPathLength[,j] = 0.  Note RN$downstreamPathLength[,] = 0 includeDownstreamNode = FALSE; alternatively, RN$downstreamPathLength[,] = OCN$RN$leng[].  spam object. RN$downstreamLengthUnconnected Matrix (OCN$RN$nNodes OCN$RN$nNodes). RN$downstreamLengthUnconnected[,j]  length downstream portion path joining node j j connected downstream path. Specifically, RN$downstreamLengthUnconnected[,j] = RN$downstreamPathLength[,k], k node exist downstream  path k j k, paths shortest possible. Note length upstream portion  path joining j given RN$downstreamLengthUnconnected[j,]. instead j joined  downstream path, RN$downstreamLengthUnconnected[,j] = 0. present includeUnconnectedPaths = TRUE. AG$downstreamPath List (length OCN$AG$nNodes) whose object list (length OCN$AG$nNodes).  nodes j connected downstream path, AG$downstreamPath[[]][[j]] vector  containing indices nodes constituting path (j included). j connected  downstream path, AG$downstreamPath[[]][[j]] = NULL. present includePaths = TRUE. AG$downstreamPathLength Sparse matrix (OCN$AG$nNodes OCN$AG$nNodes) containing length paths nodes  connected downstream path; j connected downstream path, AG$downstreamPathLength[,j] = 0.  Note AG$downstreamPathLength[,] = 0 includeDownstreamNode = FALSE; alternatively, AG$downstreamPathLength[,] = OCN$AG$leng[].  spam object. AG$downstreamLengthUnconnected Matrix (OCN$AG$nNodes OCN$AG$nNodes). AG$downstreamLengthUnconnected[,j]  length downstream portion path joining node j j connected downstream path. Specifically, AG$downstreamLengthUnconnected[,j] = AG$downstreamPathLength[,k], k node exist downstream  path k j k, paths shortest possible. Note length upstream portion  path joining j given AG$downstreamLengthUnconnected[j,]. instead j joined  downstream path, AG$downstreamLengthUnconnected[,j] = 0. present includeUnconnectedPaths = TRUE.","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/paths_OCN.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate paths between nodes in an Optimal Channel Network — paths_OCN","text":"","code":"# 1) Calculate paths between nodes of an OCN OCN <- paths_OCN(aggregate_OCN(landscape_OCN(OCN_20), thrA = 4)) if (FALSE) { # 2) Display distance to outlet (at the RN level) along the main stem # of an OCN OCN <- aggregate_OCN(landscape_OCN(OCN_250_T)) # this takes some seconds OCN <- paths_OCN(OCN, includePaths = TRUE) # this takes some seconds  distanceToOutlet <- OCN$RN$downstreamPathLength[,OCN$RN$outlet] farthestNode <- which(distanceToOutlet == max(distanceToOutlet)) mainStem <- OCN$RN$downstreamPath[[farthestNode]][[OCN$RN$outlet]] theme <- rep(NaN, OCN$RN$nNodes) theme[mainStem] <- distanceToOutlet[mainStem]  draw_thematic_OCN(theme, OCN) title(\"Distance to outlet along the main stem [pixel units]\") }"},{"path":"https://lucarraro.github.io/OCNet/reference/rivergeometry_OCN.html","id":null,"dir":"Reference","previous_headings":"","what":"River geometry of an Optimal Channel Network — rivergeometry_OCN","title":"River geometry of an Optimal Channel Network — rivergeometry_OCN","text":"Function calculates river width, depth water velocity applying Leopold's scaling relationships nodes RN AG levels.","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/rivergeometry_OCN.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"River geometry of an Optimal Channel Network — rivergeometry_OCN","text":"","code":"rivergeometry_OCN(OCN, widthMax = 1, depthMax = 1,   velocityMax = 1, expWidth = NaN, expDepth = NaN,   expVelocity = NaN)"},{"path":"https://lucarraro.github.io/OCNet/reference/rivergeometry_OCN.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"River geometry of an Optimal Channel Network — rivergeometry_OCN","text":"OCN List produced aggregate_OCN. widthMax Maximum river width allowed. nOutlet = 1, corresponds width outlet node. depthMax Maximum river depth allowed. nOutlet = 1, corresponds depth outlet node. velocityMax Maximum water velocity allowed. nOutlet = 1, corresponds water velocity outlet node. expWidth, expDepth, expVelocity Exponents power law relationship river width, depth, water velocity  contributing area. none expWidth, expDepth, expVelocity specified user, values  expWidth = 0.5, expDepth = 0.4, expDepth = 0.1 proposed Leopold Maddock [1953] used.  possible specify two three exponents, provided lies range (0; 1) sum lower one.  case, missing exponent calculated complement one sum two values provided.  three exponents specified user, sum must equal one.","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/rivergeometry_OCN.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"River geometry of an Optimal Channel Network — rivergeometry_OCN","text":"list contains objects contained OCN, addition objects listed . RN$width Vector (length OCN$RN$nNodes) river width values every RN node. RN$depth Vector (length OCN$RN$nNodes) river depth values every RN node. RN$velocity Vector (length OCN$RN$nNodes) water velocity values every RN node. AG$width Vector (length OCN$AG$nNodes) river width values every AG node. AG$depth Vector (length OCN$AG$nNodes) river depth values every AG node. AG$velocity Vector (length OCN$AG$nNodes) water velocity values every AG node. Finally, widthMax, depthMax, velocityMax, expWidth, expDepth, expVelocity added list.","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/rivergeometry_OCN.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"River geometry of an Optimal Channel Network — rivergeometry_OCN","text":"values contributing area used evaluate river geometry AG level equal 0.5*(OCN$AG$+ OCN$AG$AReach). See also aggregate_OCN. See also Leopold, L. B., & Maddock, T. (1953). hydraulic geometry stream channels physiographic implications  (Vol. 252). US Government Printing Office.","code":""},{"path":"https://lucarraro.github.io/OCNet/reference/rivergeometry_OCN.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"River geometry of an Optimal Channel Network — rivergeometry_OCN","text":"","code":"# 1) Compute river geometry of a 20x20 OCN with default options # and display river width at the RN level OCN <- rivergeometry_OCN(aggregate_OCN(landscape_OCN(OCN_20))) draw_thematic_OCN(OCN$RN$width,OCN)"},{"path":[]},{"path":"https://lucarraro.github.io/OCNet/news/index.html","id":"minor-changes-0-7-0-9000","dir":"Changelog","previous_headings":"","what":"Minor changes","title":"OCNet 0.7.0.9000","text":"draw_elev2D_OCN, draw_elev3D_OCN: args_imagePlot argument added. draw_subcatchments_OCN: add args_imagePlot arguments added. draw_thematic_OCN: add, args_imagePlot, args_legend arguments relative examples added.","code":""},{"path":"https://lucarraro.github.io/OCNet/news/index.html","id":"ocnet-070","dir":"Changelog","previous_headings":"","what":"OCNet 0.7.0","title":"OCNet 0.7.0","text":"CRAN release: 2023-02-23","code":""},{"path":"https://lucarraro.github.io/OCNet/news/index.html","id":"major-changes-0-7-0","dir":"Changelog","previous_headings":"","what":"Major changes","title":"OCNet 0.7.0","text":"create_OCN: initialization algorithm improved. landscape_OCN: algorithm improved. aggregate_OCN: displayUpdates argument added. Improved algorithm. paths_OCN: level argument added. draw_thematic_OCN: algorithm improved. draw_subcatchments_OCN: theme argument relative example added. min_lwd max_lwd added drawing functions.","code":""},{"path":"https://lucarraro.github.io/OCNet/news/index.html","id":"bugs-fixed-0-7-0","dir":"Changelog","previous_headings":"","what":"Bugs fixed","title":"OCNet 0.7.0","text":"paths_OCN: Fixed bug number nodes large","code":""},{"path":"https://lucarraro.github.io/OCNet/news/index.html","id":"ocnet-060","dir":"Changelog","previous_headings":"","what":"OCNet 0.6.0","title":"OCNet 0.6.0","text":"CRAN release: 2023-02-02","code":""},{"path":"https://lucarraro.github.io/OCNet/news/index.html","id":"major-changes-0-6-0","dir":"Changelog","previous_headings":"","what":"Major changes","title":"OCNet 0.6.0","text":"create_general_contour_OCN: function added. draw_thematic_OCN: ... argument relative example added. aggregate_OCN: breakpoints argument relative example added. OCN_to_SSN: obsSites, predSites, randomAllocation arguments added.","code":""},{"path":"https://lucarraro.github.io/OCNet/news/index.html","id":"minor-changes-0-6-0","dir":"Changelog","previous_headings":"","what":"Minor changes","title":"OCNet 0.6.0","text":"functions updated consistence/compatibility create_general_contour_OCN. draw_thematic_OCN: default option theme added; inverted order input variables (backward compatibility maintained); functioning colLevels improved.","code":""},{"path":"https://lucarraro.github.io/OCNet/news/index.html","id":"bugs-fixed-0-6-0","dir":"Changelog","previous_headings":"","what":"Bugs fixed","title":"OCNet 0.6.0","text":"paths_OCN: corrected bug includeDownstreamNode = TRUE.","code":""},{"path":"https://lucarraro.github.io/OCNet/news/index.html","id":"ocnet-051","dir":"Changelog","previous_headings":"","what":"OCNet 0.5.1","title":"OCNet 0.5.1","text":"CRAN release: 2022-12-15","code":""},{"path":"https://lucarraro.github.io/OCNet/news/index.html","id":"bugs-fixed-0-5-1","dir":"Changelog","previous_headings":"","what":"Bugs fixed","title":"OCNet 0.5.1","text":"paths_OCN: corrected bug export downstreamPath. Option displayUpdates added. Example continue_OCN modified.","code":""},{"path":"https://lucarraro.github.io/OCNet/news/index.html","id":"ocnet-050","dir":"Changelog","previous_headings":"","what":"OCNet 0.5.0","title":"OCNet 0.5.0","text":"CRAN release: 2021-05-17","code":""},{"path":"https://lucarraro.github.io/OCNet/news/index.html","id":"major-changes-0-5-0","dir":"Changelog","previous_headings":"","what":"Major changes","title":"OCNet 0.5.0","text":"paths_OCN: improved algorithm. Option includeUnconnectedPaths added. Option includePaths replaces pathsRN.","code":""},{"path":"https://lucarraro.github.io/OCNet/news/index.html","id":"ocnet-040","dir":"Changelog","previous_headings":"","what":"OCNet 0.4.0","title":"OCNet 0.4.0","text":"CRAN release: 2021-03-02","code":""},{"path":"https://lucarraro.github.io/OCNet/news/index.html","id":"major-changes-0-4-0","dir":"Changelog","previous_headings":"","what":"Major changes","title":"OCNet 0.4.0","text":"continue_OCN: function added","code":""},{"path":"https://lucarraro.github.io/OCNet/news/index.html","id":"bugs-fixed-0-4-0","dir":"Changelog","previous_headings":"","what":"Bugs fixed","title":"OCNet 0.4.0","text":"paths_OCN: Fixed bug number nodes large","code":""},{"path":"https://lucarraro.github.io/OCNet/news/index.html","id":"others-0-4-0","dir":"Changelog","previous_headings":"","what":"Others","title":"OCNet 0.4.0","text":"create_OCN: OCN$energyInit, OCN$FD$perm added output","code":""},{"path":"https://lucarraro.github.io/OCNet/news/index.html","id":"ocnet-032","dir":"Changelog","previous_headings":"","what":"OCNet 0.3.2","title":"OCNet 0.3.2","text":"CRAN release: 2020-07-23 CITATION updated","code":""},{"path":"https://lucarraro.github.io/OCNet/news/index.html","id":"ocnet-031","dir":"Changelog","previous_headings":"","what":"OCNet 0.3.1","title":"OCNet 0.3.1","text":"CRAN release: 2020-06-26","code":""},{"path":"https://lucarraro.github.io/OCNet/news/index.html","id":"bugs-fixed-0-3-1","dir":"Changelog","previous_headings":"","what":"Bugs fixed","title":"OCNet 0.3.1","text":"draw_contour_OCN: corrected issue example 2","code":""},{"path":"https://lucarraro.github.io/OCNet/news/index.html","id":"ocnet-030","dir":"Changelog","previous_headings":"","what":"OCNet 0.3.0","title":"OCNet 0.3.0","text":"CRAN release: 2020-05-12","code":""},{"path":"https://lucarraro.github.io/OCNet/news/index.html","id":"major-changes-0-3-0","dir":"Changelog","previous_headings":"","what":"Major changes","title":"OCNet 0.3.0","text":"aggregate_OCN, find_area_theshold_OCN: functioning maxReachLength option changed","code":""},{"path":"https://lucarraro.github.io/OCNet/news/index.html","id":"bugs-fixed-0-3-0","dir":"Changelog","previous_headings":"","what":"Bugs fixed","title":"OCNet 0.3.0","text":"aggregate_OCN: fixed issue calculation RN$toCM AG$toCM aggregate_OCN, find_area_theshold_OCN: maxReachLength streamOrderType returned draw_elev2D_OCN: added option addLegend draw_thematic_OCN: added option nodeType, documentation updated","code":""},{"path":"https://lucarraro.github.io/OCNet/news/index.html","id":"ocnet-020","dir":"Changelog","previous_headings":"","what":"OCNet 0.2.0","title":"OCNet 0.2.0","text":"CRAN release: 2020-02-19","code":""},{"path":"https://lucarraro.github.io/OCNet/news/index.html","id":"major-changes-0-2-0","dir":"Changelog","previous_headings":"","what":"Major changes","title":"OCNet 0.2.0","text":"create_OCN: changed coolingRate definition create_OCN: perimeteral pixels next outlets rewired create_OCN: default values nIter, coolingRate changed create_OCN: changed initial network state nOutlet > 1 uploaded data re-created accordance new settings","code":""},{"path":"https://lucarraro.github.io/OCNet/news/index.html","id":"bugs-fixed-0-2-0","dir":"Changelog","previous_headings":"","what":"Bugs fixed","title":"OCNet 0.2.0","text":"create_OCN: allowed nIter < 2 draw_thematic_OCN: fixed backgroundColor issue chooseCM = TRUE landscape_OCN: fixed displayUpdates issue paths_OCN: added option includeDownstreamNode find_area_theshold_OCN: allowed nNodesRN < 2 create_OCN: added option easyDraw draw_thematic_OCN: added option chooseAggregation","code":""},{"path":"https://lucarraro.github.io/OCNet/news/index.html","id":"others-0-2-0","dir":"Changelog","previous_headings":"","what":"Others","title":"OCNet 0.2.0","text":"CITATION added vignette: metapopulation model updated","code":""}]
